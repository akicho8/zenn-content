---
title: "Nannouã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å‚è€ƒã—ã¦ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œã£ã¦ã¿ãŸ"
emoji: "ğŸ£"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Rust", "Nannou"]
published: true
---

## ã¯ã˜ã‚ã«

https://www.youtube.com/watch?v=mvWtkKcxYV0

Nannou ã§ã‚ã‚Œã“ã‚Œè©¦ã™ã¨ãã«å…¬å¼ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å‚è€ƒã«ã—ãªãŒã‚‰ã„ã‚ã„ã‚è¿½åŠ ã—ã¦ã„ãã®ãŒæ‰‹é–“ã ã£ãŸã®ã§ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½œã‚Šã¾ã—ãŸã€‚
ã¨ã‚Šã‚ãˆãšã“ã‚Œã‚’å…ƒã«ã—ã¦ã€ã„ã‚‰ãªã„ã®ã¯æ¶ˆã—ã¦ã„ãæ„Ÿã˜ã§ã™ã€‚

## ã‚³ãƒ¼ãƒ‰

```rust:template.rs
// ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
// https://docs.rs/nannou/latest/nannou/
//
// è‰²åä¸€è¦§
// https://docs.rs/nannou/latest/nannou/color/named/index.html

use nannou::prelude::*;

// 1ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹
// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã™ã‚‹ä¾‹ã¨ã—ã¦ã‚ã‹ã‚Šã‚„ã™ã„
mod ball;
use crate::ball::Ball;

// è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç®¡ç†ã™ã‚‹1ã¤ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¾‹
// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã™ã‚‹ä¾‹ã¨ã—ã¦ã‚ã‹ã‚Šã‚„ã™ã„
mod particle_system;
use crate::particle_system::ParticleSystem;

// ç¹°ã‚Šè¿”ã—å‡¦ç†ã§ä¾¿åˆ©ãªã®ã§ã¨ã‚Šã‚ãˆãšå…¥ã‚Œã¨ã“ã†
#[allow(unused_imports)]
use itertools::Itertools;

struct Model {
    any_value1: isize,  // ä½•ã‹
    mouse_down: bool,   // å·¦ã‚¯ãƒªãƒƒã‚¯ã§ true ã«ãªã‚‹
    ball: Ball,         // ä¸­å¤®ã‚’ã¾ã‚ã‚‹ç‰©ä½“
    ps: ParticleSystem, // ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰å™´å°„ã™ã‚‹ç‰©ä½“ã‚’ç®¡ç†ã—ã¦ã‚‹ã‚„ã¤
}

impl Model {
    // Model å†…ã®ãƒ¡ãƒ³ãƒãƒ¼å¤‰æ•°ã‚’æ“ä½œã™ã‚‹ã¾ã¨ã¾ã£ãŸå‡¦ç†ã¯ã“ã“ã«æ›¸ã
    // ãã‚ŒãŒã¾ã¨ã¾ã£ãŸã‚‰ Ball ã¿ãŸã„ã«åˆ¥ã®ã‚¯ãƒ©ã‚¹ã«ã™ã‚‹
    fn any_value1_change(&mut self, sign: isize) {
        self.any_value1 += sign;
    }
}

fn main() {
    // ãŠç´„æŸ
    nannou::app(model).event(event).update(update).run();
}

fn model(app: &App) -> Model {
    // ã“ã“ã‚‰ã¸ã‚“ã‚‚ãŠç´„æŸ
    app.new_window()
        .size(640, 480) // ã‚ã¨ã‹ã‚‰ã¯ app.window_rect() ã§ã‚ã‹ã‚‹ã®ã§å®šæ•°ã«ã—ãªãã¦ã‚‚ã‚ˆã‹ã‚ã†
        .mouse_pressed(mouse_pressed)
        .mouse_released(mouse_released)
        .view(view)
        .build()
        .unwrap();

    // Windowã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥ã‚Œã‚‹å ´åˆ
    if true {
        app.main_window().set_title("Nannou all in one template");
    }

    // Model ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™æ±ºã¾ã‚Šã«ãªã£ã¦ã„ã‚‹
    Model {
        any_value1: 0,
        mouse_down: false,
        ball: Ball::new(DODGERBLUE),
        ps: ParticleSystem::new(),
    }
}

fn event(app: &App, model: &mut Model, event: Event) {
    if let Event::WindowEvent {
        simple: Some(KeyPressed(key)),
        ..
    } = event
    {
        // ã‚­ãƒ¼ã‚’å©ã„ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ä»»æ„ã®å‡¦ç†ã‚’1å›ã ã‘è¡Œã†ã¨ãç”¨
        // æŠ¼ã—ã£ã±ãªã—ã«ã¯ãªã‚‰ãªã„
        match key {
            Key::Z     => {},
            Key::X     => {},
            Key::C     => {},
            Key::Space => {},
            
            Key::Left => model.any_value1_change(-1),
            Key::Right => model.any_value1_change(1),

            // ãƒã‚¦ã‚¹ã‚’å‹•ã‹ã—ãŸã¨ãã ã‘æç”»ã™ã‚‹ãƒ¢ãƒ¼ãƒ‰
            Key::Key0 => app.set_loop_mode(LoopMode::Wait),

            // å‚ç›´åŒæœŸãƒ¢ãƒ¼ãƒ‰ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            Key::Key1 => app.set_loop_mode(LoopMode::RefreshSync),

            // 1å›æç”»ã—ãŸã‚‰æç”»ã‚’æ­¢ã‚ã‚‹ (PAUSEã¨ã—ã¦ä½¿ãˆã‚‹)
            Key::P => app.set_loop_mode(LoopMode::loop_once()),

            // ã“ã‚ŒåŠ¹ã„ã¦ãªã„(ãªã‚“ã§ï¼Ÿ)
            Key::Key3 => app.set_loop_mode(LoopMode::rate_fps(30.0)),
            Key::Key6 => app.set_loop_mode(LoopMode::rate_fps(60.0)),

            // å…¨ç”»é¢ãƒ¢ãƒ¼ãƒ‰ã¯è¨­å®šã—ãªãã¦ã‚‚æœ€åˆã‹ã‚‰ Command + f ã§è¡Œãˆã‚‹
            // Key::F => app.main_window().set_fullscreen(true),

            // ã‚¢ãƒ—ãƒªçµ‚äº† (Escã§ã‚‚çµ‚äº†ã§ãã‚‹)
            Key::Q => app.quit(),

            // ç”»é¢ã‚’ç”»åƒã¨ã—ã¦ä¿å­˜ã™ã‚‹
            Key::S => app
                .main_window()
                .capture_frame(app.exe_name().unwrap() + ".png"),

            _ => {}
        }
    }
}

fn mouse_pressed(_app: &App, model: &mut Model, button: MouseButton) {
    match button {
        MouseButton::Left => model.mouse_down = true,
        MouseButton::Right => {},
        _ => {}
    }
}

fn mouse_released(_app: &App, model: &mut Model, button: MouseButton) {
    match button {
        MouseButton::Left => model.mouse_down = false,
        MouseButton::Right => {},
        _ => {}
    }
}

// ä½•ã‹å‹•ã‹ã™ã¨ãã®å‡¦ç†
fn update(app: &App, model: &mut Model, _update: Update) {
    // ãƒœãƒ¼ãƒ«ã‚’å‹•ã‹ã™
    if true {
        model.ball.update(&app);
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‹•ã‹ã™
    if true {
        model.ps.origin = pt2(app.mouse.x, app.mouse.y);
        if (((app.time * 60.0) as usize) % 3) == 0 { // 3ãƒ•ãƒ¬ãƒ¼ãƒ æ¯ã«1ç™º
            model.ps.add_particle();
        }
        model.ps.update();
    }
}

// è¡¨ç¤ºå‡¦ç†
// è¡Œå„€ã®è‰¯ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ããªã‚‰ã“ã“ã§ model ã®æ›´æ–°ã¯ã—ãªã„æ–¹ãŒã„ã„
fn view(app: &App, model: &Model, frame: Frame) {
    let draw = app.draw();
    let win = app.window_rect();

    // å…¨æ¶ˆå» (æ®‹åƒãªã—)
    if true {
        frame.clear(hsl(240.0 / 360.0, 1.0, 0.03));
    }

    // å…¨æ¶ˆå» (æ®‹åƒã‚ã‚Š)
    if false {
        draw.rect()
            .wh(app.window_rect().wh())
            .hsla(240.0 / 360.0, 1.0, 0.03, 0.1);
    }

    // å·¦ä¸Šã‹ã‚‰ãƒã‚¦ã‚¹ã«ç·š
    if true {
        let start = win.top_left();
        let mouse = app.mouse.position();
        draw.line().points(start, mouse).color(DODGERBLUE);
    }

    // å·¦ä¸Šã«é•·æ–¹å½¢
    if true {
        let r = Rect::from_w_h(100.0, 100.0);
        let r = r.top_left_of(win.pad(30.0)); // ä½™ç™½
        draw.rect()
            .xy(r.xy())
            .wh(r.wh())
            .hsla(1.0, 1.0, 1.0, 0.0)
            .stroke_weight(1.0) // æ ã‚’æ›¸ãã¨ãã¯å¿…é ˆ
            .stroke(DODGERBLUE);
    }

    // å³ä¸‹ã«å††
    if true {
        let r = Rect::from_w_h(100.0, 100.0);
        let r = r.bottom_right_of(win.pad(30.0)); // ä½™ç™½
        draw.ellipse()
            .xy(r.xy())
            .wh(r.wh())
            .hsla(1.0, 1.0, 1.0, 0.0)
            .stroke_weight(1.0) // æ ã‚’æ›¸ãã¨ãã¯å¿…é ˆ
            .stroke(DODGERBLUE);
    }

    // å·¦ä¸‹ã«ä¸‰è§’
    if true {
        let r = Rect::from_w_h(100.0, 100.0);
        let r = r.bottom_left_of(win.pad(30.0)); // ä½™ç™½
        draw.tri()
            .points(r.bottom_left(), r.mid_top(), r.bottom_right())
            .hsla(1.0, 1.0, 1.0, 0.0)
            .stroke_weight(1.0)
            // .rotate(app.time)
            .stroke(DODGERBLUE);
    }

    // ä¸­å¤®ã‹ã‚‰ãƒã‚¦ã‚¹ã«çŸ¢å°
    if true {
        draw.arrow()
            .start_cap_round()
            .weight(3.0)        // å¤ªã•
            .points(vec2(0.0, 0.0), app.mouse.position())
            .color(DODGERBLUE);
    }

    // ä¸­å¤®ã‹ã‚‰åå­—çŸ¢å°
    if true {
        let crosshair_color = DODGERBLUE;
        let ends = [
            win.mid_top(),
            win.mid_right(),
            win.mid_bottom(),
            win.mid_left(),
        ];
        ends.iter().for_each(|&end| {
            draw.arrow()
                .start_cap_round()
                .head_length(16.0)
                .head_width(8.0)
                .color(crosshair_color)
                .end(end);
        })
    }

    // ãƒã‚¦ã‚¹åº§æ¨™ã‚’ãƒã‚¦ã‚¹ä½ç½®ã«è¡¨ç¤º
    if true {
        let mouse = app.mouse.position();
        let pos = format!("[{:.1}, {:.1}]", mouse.x, mouse.y);
        draw.text(&pos)
            .xy(mouse + vec2(0.0, 20.0))
            .font_size(14)
            .color(DODGERBLUE);
    }

    // ãƒã‚¦ã‚¹ã®è¡›æ˜Ÿ
    if true {
        let x = (app.time * 5.0 * 0.3).cos() * win.w() / 2.0;
        let y = (app.time * 6.0 * 0.3).sin() * win.h() / 2.0;
        // map_range ã‚’ä½¿ã†å ´åˆ
        // nannou ã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯å˜ã« * win.w() / 2.0 ãªã©ã¨ã›ãš map_range ã§åºƒã’ã¦ã„ã‚‹
        // let x = (app.time * 5.0 * 0.3).cos();
        // let y = (app.time * 6.0 * 0.3).sin();
        // let x = map_range(x, -1.0, 1.0, win.left(), win.right());
        // let y = map_range(y, -1.0, 1.0, win.bottom(), win.top());
        draw.ellipse().x_y(x, y).color(DODGERBLUE);
    }

    // ä¸­å¤®ã®5è§’å½¢
    if true {
        let n = 5;
        let list = (0..n + 1).map(|i| {
            let angle = 2.0 * PI / (n as f32) * (i as f32);
            pt2(angle.sin(), angle.cos()) * 100.0
        });
        draw.polyline()
            .rotate(-app.time)
            .stroke_weight(5.0)
            .points(list)
            .color(DODGERBLUE);
    }

    // ä½•ã‹æŠ¼ã—ã¦ã„ã‚‹ã¨ãä½•ã‹ã™ã‚‹å‡¦ç†
    // ã‚­ãƒ¼ã®ãƒã‚§ãƒƒã‚¯ã¯ fn event å†…ã§è¡Œã‚ãªã„ã¨ã„ã‘ãªã„ã‚ã‘ã§ã¯ãªã„
    if true {
        if app.keys.down.contains(&Key::Z) {
            println!("{:?}", app.keys.down);
        }
        if app.keys.down.contains(&Key::X) {
            println!("{:?}", app.keys.down);
        }
        if app.keys.down.contains(&Key::C) {
            println!("{:?}", app.keys.down);
        }
    }

    // æç”»å‡¦ç†ã¯ã“ã“ã«æ›¸ã‹ãšã«å§”è­²ã™ã‚‹ä¾‹
    if true {
        model.ball.display(&draw);
        model.ps.draw(&draw);
    }

    // ã‚¢ãƒ—ãƒªæƒ…å ±ã‚’è¡¨ç¤º
    if true {
        let r = Rect::from_w_h(win.w(), 22.0).bottom_left_of(win.pad(0.0));
        // draw.rect().xy(r.xy()).wh(r.wh()).rgb(0.0, 0.0, 0.4);
        let text = format!("{:?} {}", model.mouse_down, model.any_value1);
        draw.text(&text).xy(r.xy()).wh(r.wh()).color(CORNFLOWERBLUE);
    }

    // ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±ã‚’è¡¨ç¤º
    // æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æç”»ã—ã¦ã„ã‚‹ã®ã‹ã‚ã‹ã‚‹ã‚ˆã†ã«æç”»æ•°ã‚„FPSã¯å¸¸ã«è¡¨ç¤ºã—ã¦ãŠãã®ãŒãŠã™ã™ã‚
    if true {
        let r = Rect::from_w_h(win.w(), 22.0).top_left_of(win.pad(0.0));
        let text = format!(
            "{} {:.2} {:.0}fps {:?} {}x{} M({:.0},{:.0}) {:.0} ",
            frame.nth(),
            app.time,
            app.fps(),
            app.loop_mode(),
            win.w(),
            win.h(),
            app.mouse.x,
            app.mouse.y,
            app.mouse.position().length(),
        );
        draw.text(&text)
            .xy(r.xy())
            .wh(r.wh())
            .left_justify()
             // .align_text_top()
            .color(CORNFLOWERBLUE);
    }

    draw.to_frame(app, &frame).unwrap();
}
```

```rust:ball.rs
// å‚è€ƒ
// https://github.com/nannou-org/nannou/blob/master/examples/rust_basics/7_modules/ball.rs

use nannou::prelude::*;

pub struct Ball {
    pub position: Point2,
    color: Srgb<u8>,
    alive_counter: f32,
}

impl Ball {
    pub fn new(color: Srgb<u8>) -> Self {
        Ball {
            color: color,
            position: pt2(0.0, 0.0),
            alive_counter: 0.0,
        }
    }

    pub fn update(&mut self, app: &App) {
        self.position = pt2(app.mouse.x, app.mouse.y);
        self.alive_counter += 1.0;
    }

    pub fn display(&self, draw: &Draw) {
        let x = self.position.x + (self.alive_counter * 0.10).cos() * 50.0;
        let y = self.position.y + (self.alive_counter * 0.10).sin() * 50.0;
        draw.ellipse()
            .x_y(x, y)
            .radius(8.0)
            .color(self.color);
    }
}
```

```rust:particle_system.rs
// â†“ã‚ªãƒªã‚¸ãƒŠãƒ«
// https://github.com/nannou-org/nannou/blob/master/nature_of_code/chp_04_systems/4_03_exercise_moving_particle_system.rs
//
// The Nature of Code
// Daniel Shiffman
// http://natureofcode.com
//
// example 4-03: Exercise Moving Particle System
use nannou::prelude::*;

struct Particle {
    position: Point2,
    velocity: Vec2,
    acceleration: Vec2,
    alive_counter: f32,
}

impl Particle {
    fn new(l: Point2) -> Self {
        let acceleration = vec2(0.0, 0.08);
        let velocity = vec2(random_f32() * 1.0 - 0.5, -4.0 + random_f32() * -4.0);
        let position = l;
        let alive_counter = 0.0;
        Particle {
            acceleration,
            velocity,
            position,
            alive_counter,
        }
    }

    fn update(&mut self) {
        self.velocity += self.acceleration;
        self.position -= self.velocity;
        self.alive_counter += 1.0;
    }

    fn display(&self, draw: &Draw) {
        draw.rect()
            .xy(self.position)
            .w_h(4.0, 4.0)
            .color(DODGERBLUE);
    }

    fn is_dead(&self) -> bool {
        self.alive_counter >= 60.0 * 4.0
    }
}

pub struct ParticleSystem {
    particles: Vec<Particle>,
    pub origin: Point2,
}

impl ParticleSystem {
    pub fn new() -> Self {
        let origin = pt2(0.0, 0.0);
        let particles = Vec::new();
        ParticleSystem { origin, particles }
    }

    pub fn add_particle(&mut self) {
        self.particles.push(Particle::new(self.origin));
    }

    pub fn update(&mut self) {
        // FIXME: ã‚‚ã†ã¡ã‚‡ã£ã¨ç¶ºéº—ã«æ›¸ã‘ãªã„ã‚‚ã®ã‹
        for i in (0..self.particles.len()).rev() {
            self.particles[i].update(); // FIXME: æ·»å­—ã‚¢ã‚¯ã‚»ã‚¹ã¯æ­¢ã‚ãŸã„
            if self.particles[i].is_dead() {
                self.particles.remove(i);
            }
        }
    }

    pub fn draw(&self, draw: &Draw) {
        for p in self.particles.iter() {
            p.display(&draw);
        }
    }
}
```

## åˆã‚ã¦ã®æ–¹ã¸ã®Nannouã®å°å…¥ã¨å®Ÿè¡Œæ‰‹é †

`~/src/nannou_playground` ã®ãªã‹ã«ä½œã‚‹ã¨ã—ã¾ã™ã€‚

```shell:shell
cd ~/src
cargo new nannou_playground
cd nannou_playground
cargo add nannou
cargo add itertools
mkdir -p examples
cd examples
```

ã¨ã—ã¦ examples ã®ãªã‹ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç½®ã„ã¦ã„ãã¾ã™ã€‚
ãã“ã§ `examples/template.rs` ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ `cargo run --example template` ã¨ã—ã¾ã™ã€‚
`src/main.rs` ã®æ–¹ã«æ›¸ã„ã¦ã‚‚ã„ã„ã‚“ã§ã™ãŒã€ã„ãã¤ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã£ã¦ã„ã‚ã„ã‚è©¦ã™ã¨ãã¯ examples ã®ä¸­ã«ä½œã‚‹ã¨åˆ‡ã‚Šæ›¿ãˆã‚„ã™ã„ã§ã™ã€‚

## å‚è€ƒ

https://programing.style/archives/70
