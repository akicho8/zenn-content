---
title: "ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³çš„ãªã‚„ã¤ã‚’å­¦ã³ç›´ã™"
emoji: "ğŸ˜º"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Ruby", "ãƒ‡ã‚¶ãƒ‘ã‚¿", "designpattern"]
published: false
---

# æ¦‚ç•¥ #

## ä¸€èˆ¬ (GOF) ##

| åå‰                    | æ¦‚è¦                                                      |
|-------------------------|-----------------------------------------------------------|
| Adapter                 | ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¶³ã‚Šãªãã¦éšå±¤çš„ã«å¢—ã‚„ã™ã¨ãã«ä½¿ã†(é‡è¦)        |
| Observer                | é€šçŸ¥å…ƒã¯é€šçŸ¥å…ˆã®ã“ã¨ã‚’çŸ¥ã‚‰ãªã„ã§ã‚ˆã„ã“ã¨ãŒå‰æ            |
| Iterator                | each ã®ã“ã¨                                               |
| Template Method         | new ã™ã‚‹ã¨ initialize                                     |
| Singleton               | ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ã—ãŸã„ã¨ãç”¨                |
| Prototype               | new ã§ã¯ãªã clone ã§                                     |
| Builder                 | xml.body {xml.p("x")}                                     |
| Abstract Factory        | ã‚¯ãƒ©ã‚¹ã‚’ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ãªã„                          |
| Strategy                | ãƒ†ãƒˆãƒªãƒŸãƒã®ãƒ„ãƒ¢                                          |
| Composite               | def x; @commands.collect(&:x); end                        |
| Decorator               | to_html ã‚’ã¤ã‘ãŸã„ã‘ã©å…ƒã®ã‚¯ãƒ©ã‚¹ã¯æ±šã—ãŸããªã„ã¨ãç”¨      |
| Visitor                 | Pathname.glob("*.rb") {...}                               |
| Chain of Responsibility | resolve? ãªã‚‰å—ã‘ã‚‹ã€‚(é †ã«ãƒªãƒ³ã‚¯ã—ã¦ãªã„ã¨ã„ã‘ãªã„ã‹ç–‘å•) |
| Facade                  | å˜ã«ãƒ¡ã‚½ãƒƒãƒ‰åŒ–ï¼Ÿ                                          |
| Mediator                | A ã¨ B ã§å›°ã£ãŸã‚‰ Mediator ã‚¯ãƒ©ã‚¹ãŒå¿…è¦                   |
| Memento                 | å‰ã®çŠ¶æ…‹ã«æˆ»ã‚ŠãŸã„ã¨ãç”¨                                  |
| State                   | ä¸€æ®µéšå±¤ã‚’æ·±ãã—ã¦ãƒ•ãƒ©ãƒƒãƒˆã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹      |
| Flyweight               | ãƒ¡ãƒ¢åŒ–ã®ã“ã¨ã€‚ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ—ãƒ¼ãƒ«ã¨ã‚‚è¨€ã†                  |
| Proxy                   | å¿…è¦ã«ãªã£ã¦ã‹ã‚‰ä½œã‚‹                                      |
| Command                 | å‘½ä»¤ã‚’ã‚¯ãƒ©ã‚¹ã«ã™ã‚‹                                        |
| Interpreter             | æ–‡æ³•è¦å‰‡ã‚’ã‚¯ãƒ©ã‚¹ã§è¡¨ç¾                                    |

## ã‚¹ãƒ¬ãƒƒãƒ‰ç”¨ ##

| åå‰                      | å‚™è€ƒ                                  |
|---------------------------|---------------------------------------|
| Single Threaded Execution | æ’ä»–åˆ¶å¾¡ â†’ ã™ã‚‹                      |
| Immutable                 | æ’ä»–åˆ¶å¾¡ â†’ ã—ãªã„ã§ã„ã„              |
| Guarded Suspension        | å‡¦ç†ã§ãã‚‹ã¾ã§ â†’ å¾…ã¤ (åˆ¥ã«å¢—ãˆãªã„) |
| Worker Thread             | å‡¦ç†ã§ãã‚‹ã¾ã§ â†’ å¾…ã¤ (å¢—ãˆã‚‹ã¨é€Ÿã„) |
| Balking                   | å‡¦ç†ã§ãã‚‹ã¾ã§ â†’ å¾…ãŸãªã„            |
| Thread Per Message        | å‡¦ç†ã‚’æŠ•ã’ã‚‹ â†’ æˆ»å€¤ã„ã‚‰ã‚“            |
| Future                    | å‡¦ç†ã‚’æŠ•ã’ã‚‹ â†’ æˆ»å€¤ã„ã‚‹              |
| Producer-Consumer         | ä½œã‚‹ â†’ ã‚­ãƒ¥ãƒ¼ â†’ ä½¿ã†                |
| Read-Write Lock           | èª­ã¿è¾¼ã¿ä¸­ã¯æ›¸ãè¾¼ã¾ãªã„              |
| Two-Phase Termination     | å¤–ã‹ã‚‰æ®ºã•ãªã„                        |
| Thread Specific Storage   | ã‚¹ãƒ¬ãƒƒãƒ‰å€‹åˆ¥ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°          |

## ãã®ä»– ##

| åå‰               | æ¦‚è¦                                         |
|--------------------|----------------------------------------------|
| Active Object      | éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚‹                   |
| Null Object        | ãªã«ã‚‚ã—ãªã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã—ã¦ã‹ã‚ã™         |
| Object Pool        | ç”Ÿæˆã«æ™‚é–“ãŒã‹ã‹ã‚‹ã‚‚ã®ã‚’ä½¿ã„å›ã™             |
| Pluggable Selector | æ¨ªç€ãƒãƒ«ãƒ¢ãƒ«ãƒ•ã‚£ãƒƒã‚¯(ï¼Ÿ)                     |
| Before / After     | å¾Œå‡¦ç†ã‚’å¿…ãšå®Ÿè¡Œ                             |
| Factory Method     | new ã‚’åˆ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¡Œã†ã ã‘(ï¼Ÿ)           |
| Bridge             | è¦ã¯DRYã«ã—ã¨ã‘ã°æ‹¡å¼µãŒæ¥½ã¡ã‚“ã£ã¦ã“ã¨ã£ã½ã„  |
| Typed Message      | GUIã§ã‚ˆãã‚ã‚‹ SDL::Event::Quit ã¿ãŸã„ãªã‚¢ãƒ¬  |
| Cache Manager      | ä½¿ã£ãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¯å…ˆé ­ã«ç§»å‹•                 |
| Component Bus      | Observer ãŒ Subject ã‚’æ¡ã£ã¦ã„ã‚‹             |
| Composed Method    | ãƒ¡ã‚½ãƒƒãƒ‰åŒ–ã—ã¦ãªã‚“ãªã‚‰å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ |

## SOLID ##

| ç•¥  | åå‰                            | æ—¥æœ¬èª             | ä½•ãŒãƒ€ãƒ¡ï¼Ÿ                                 | æ”¹å–„æ–¹æ³•                   |
|-----|---------------------------------|--------------------|--------------------------------------------|----------------------------|
| SRP | Single Responsibility Principle | å˜ä¸€è²¬ä»»           | 1ã¤ã®ã‚¯ãƒ©ã‚¹ã«è¤‡æ•°ã®æ©Ÿèƒ½                    | ã‚¯ãƒ©ã‚¹åˆ†å‰²                 |
| OCP | Open-Closed Principle           | ã‚ªãƒ¼ãƒ—ãƒ³ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ | æ‹¡å¼µã—ãšã‚‰ãã€æ‹¡å¼µã™ã‚‹ã¨ã‚¯ãƒ©ã‚¹ã®å¤‰æ›´ãŒå¿…è¦ | å‡¦ç†ã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¸¡ã™ |
| LSP | Liskov Substitution Principle   | ãƒªã‚¹ã‚³ãƒ•ã®ç½®æ›     | ç¶™æ‰¿ã—ãŸãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã¾ã£ãŸãé•ã†ã‚‚ã®ã«ã—ãŸ   | è¦ªã‚¯ãƒ©ã‚¹ã®æ–¹é‡ã‚’å¯Ÿã™ã‚‹     |
| ISP | Interface Segregation Principle | ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹åˆ†é›¢ | æŠ½è±¡ã‚¯ãƒ©ã‚¹ãŒè¤‡é›‘                           | æŠ½è±¡ã‚¯ãƒ©ã‚¹ã‚’åˆ†å‰²           |
| DIP | Dependency Inversion Principle  | ä¾å­˜é–¢ä¿‚é€†è»¢       | ã‚¹ãƒˆãƒ©ãƒ†ã‚¸ãƒ¼ç”¨ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ä¾å­˜         | ä¾å­˜ã—ã¦ã¯ã„ã‘ãªã„         |

# ä¸€èˆ¬ (GOF) #

## Mediator ##

```ruby
class Mediator
  attr_reader :a, :b

  def initialize
    @a = A.new(self)
    @b = B.new(self)
  end

  def changed
    @b.visible = @a.state
  end
end

class A
  attr_accessor :state

  def initialize(mediator)
    @mediator = mediator
    @state = true
  end

  def changed
    @mediator.changed
  end
end

class B
  attr_accessor :visible
  def initialize(mediator)
    @mediator = mediator
  end
end

m = Mediator.new
m.a.state = true
m.a.changed
m.b.visible # => true
```

  * A ã¨ B ã¯äº’ã„ã®ã“ã¨ã‚’çŸ¥ã‚‰ãªã„
  * A ã¯å¤‰æ›´ã—ãŸã“ã¨ã‚’ B ã§ã¯ãªã Mediator ã«ä¼ãˆã‚‹
  * C ãŒã§ããŸã¨ã—ã¦ã‚‚ A ã®æŒ™å‹•ã¯å¤‰ã‚ã‚‰ãªã„
  * ã‚‚ã— Mediator ãŒãªã‘ã‚Œã° A ã¯è‡ªåŠ›ã§é–¢é€£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®èª¿æ•´ã‚’è¡Œã‚ãªã„ã¨ã„ã‘ãªã„

## Abstract Factory ##

```ruby
class Builder
  def initialize(factory)
    @factory = factory
  end

  def build
    @factory.new_a("x").build
  end
end

class A
  def initialize(value)
    @value = value
  end

  def build
    "(#{@value})"
  end
end

class FactorySet1
  def new_a(*args)
    A.new(*args)
  end
end

class B
  def initialize(value)
    @value = value
  end

  def build
    "<#{@value}>"
  end
end

class FactorySet2
  def new_a(*args)
    B.new(*args)
  end
end

Builder.new(FactorySet1.new).build # => "(x)"
Builder.new(FactorySet2.new).build # => "<x>"
```

  * ã‚ˆãã‚ã‹ã£ã¦ãªã„
  * A ã¨ B ã‚’ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã„ã‚‹ã®ã‚’ã‚„ã‚ã‚ˆã†ã£ã¦ã“ã¨ãªã®ã‹ï¼Ÿ
  * Java ã®ã‚³ãƒ¼ãƒ‰ã‚’ãã®ã¾ã¾ Ruby ã«ã—ãŸã›ã„ã§ç„¡é§„ã«è¤‡é›‘ã«ãªã£ã¦ã„ã‚‹ã‚ˆã†ãªæ°—ã‚‚ã™ã‚‹

## Factory Method ##

```ruby
class X
end

class F
  def create
    X.new
  end
end

class C
  attr_accessor :v

  def initialize(f)
    @v = f.create
  end
end

C.new(F.new).v                  # => #<X:0x007fb213905a98>
```

## Chain of Responsibility ##

```ruby
class Chainable
  def initialize(_next = nil)
    @_next = _next
  end

  def support(q)
    if resolve?(q)
      answer(q)
    elsif @_next
      @_next.support(q)
    else
      "çŸ¥ã‚‰ã‚“"
    end
  end
end

class Alice < Chainable
  def resolve?(q)
    q == "1+2ã¯ï¼Ÿ"
  end

  def answer(q)
    "3"
  end
end

class Bob < Chainable
  def resolve?(q)
    q == "2*3ã¯ï¼Ÿ"
  end

  defef answer(q)
    "6"
  end
end

alice = Alice.new(Bob.new)
alice.support("1+2ã¯ï¼Ÿ") # => "3"
alice.support("2*3ã¯ï¼Ÿ") # => "6"
alice.support("2/1ã¯ï¼Ÿ") # => "çŸ¥ã‚‰ã‚“"
```

## Proxy ##

decorator ã«ä¼¼ã¦ã„ã‚‹ã‘ã© decorator ã»ã©ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã—ãªã„ã—ä¾¿åˆ©ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚è¿½åŠ ã—ãªã„ã€‚
å…ƒã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã©ã†ã™ã‚‹ã‹ã¯ã ã„ãŸã„ã“ã®3ã¤ã«åˆ†ã‘ã‚‰ã‚Œã‚‹ã€‚

| åå‰           | æ„å‘³               |
|----------------|--------------------|
| ã‚¬ãƒ¼ãƒ‰ãƒ—ãƒ­ã‚­ã‚· | å‘¼ã¶ã‹ã€å‘¼ã°ãªã„ã‹ |
| ä»®æƒ³ãƒ—ãƒ­ã‚­ã‚·   | ã¾ã­ã‚‹             |
| é…å»¶å®Ÿè¡Œ       | ã‚ã¨ã§å‘¼ã¶         |

##### ã‚¬ãƒ¼ãƒ‰ãƒ—ãƒ­ã‚­ã‚· (å‘¼ã¶ã‹ã€å‘¼ã°ãªã„ã‹) #####

```ruby
require "active_support/core_ext/module/delegation"

class User
  attr_accessor :name, :score

  def initialize(name)
    @name = name
    @score = 0
  end
end

class UserProxy
  BLACK_LIST = ["alice"]

  delegate :score, to: :@user

  def initialize(user)
    @user = user
  end

  def method_missing(...)
    unless BLACK_LIST.include?(@user.name)
      @user.send(...)
    end
  end
end

user = User.new("alice")
user.score += 1
user.score                      # => 1

user = UserProxy.new(User.new("alice"))
user.score += 1
user.score                      # => 0
```

##### ä»®æƒ³ãƒ—ãƒ­ã‚­ã‚· (ã¾ã­ã‚‹) #####

```ruby
class VirtualPrinter
  def name
    "åˆæœŸåŒ–ãŒé…ã„ãƒ—ãƒªãƒ³ã‚¿"
  end

  def print(str)
  end
end

printer = VirtualPrinter.new
printer.name        # => "åˆæœŸåŒ–ãŒé…ã„ãƒ—ãƒªãƒ³ã‚¿"
printer.print("ok") # => nil
```

##### é…å»¶å®Ÿè¡Œ (ã‚ã¨ã§å‘¼ã¶) #####

```ruby
class VirtualPrinter
  def name
    "åˆæœŸåŒ–ãŒé…ã„ãƒ—ãƒªãƒ³ã‚¿"
  end

  def print(str)
    @printer ||= RealPrinter.new
    @printer.print(str)
  end
end

class RealPrinter
  def initialize
    puts "ã¨ã¦ã¤ã‚‚ãªãæ™‚é–“ãŒã‹ã‹ã‚‹åˆæœŸåŒ–å‡¦ç†..."
  end

  def name
    "åˆæœŸåŒ–ãŒé…ã„ãƒ—ãƒªãƒ³ã‚¿"
  end

  def print(str)
    str
  end
end

printer = VirtualPrinter.new
printer.name        # => "åˆæœŸåŒ–ãŒé…ã„ãƒ—ãƒªãƒ³ã‚¿"
printer.print("ok") # => "ok"
# >> ã¨ã¦ã¤ã‚‚ãªãæ™‚é–“ãŒã‹ã‹ã‚‹åˆæœŸåŒ–å‡¦ç†...
```

## Command + Composite ##

```ruby
class Command
end

class FooCommand < Command
  def execute
    "a"
  end
end

class BarCommand < Command
  def execute
    "b"
  end
end

class CompositeCommand < Command
  def initialize
    @commands = []
  end

  def <<(command)
    @commands << command
  end

  def execute
    @commands.collect(&:execute)
  end
end

command = CompositeCommand.new
command << FooCommand.new
command << BarCommand.new
command.execute                 # => ["a", "b"]
```

ã“ã®ã¾ã¾ã„ãã¨ã‚¯ãƒ©ã‚¹çˆ†ç™ºã—ã¦ã—ã¾ã†ã®ã§ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã†ãªã©ã—ã¦å·¥å¤«ã™ã‚‹

```ruby
class BazCommand < Command
  def initialize(&block)
    @command = block
  end

  def execute
    @command.call
  end
end

command << BazCommand.new { "c" }
command << BazCommand.new { "d" }
command.execute # => ["a", "b", "c", "d"]
```

## Prototype ##

```ruby
A = Object.clone

B = A.clone.tap do |o|
  def o.foo
    true
  end
end

B.clone.foo # => true
```

## Template Method ##

```ruby
class Base
  def run
    a + b
  end
end

class App < Base
  def a
    1
  end

  def b
    2
  end
end

App.new.run # => 3
```

initialize ã‚„ C ã® main é–¢æ•°ã‚‚æ›¸ã‘ã°æœ€åˆã«å®Ÿè¡Œã•ã‚Œã‚‹ã¨æ±ºã¾ã£ã¦ã„ã‚‹ã®ã§ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨è¨€ãˆãªãã‚‚ãªã„

## Iterator ##

i ãŒé‚ªé­”

```ruby
ary = %w(a b c)
i = 0
while i < ary.size
  p ary[i]
  i += 1
end
# >> "a"
# >> "b"
# >> "c"
```

ã“ã“ã§ Iterator

```ruby
class Iterator
  def initialize(object)
    @object = object
    @index = 0
  end

  def has_next?
    @index < @object.size
  end

  def next
    @object[@index].tap { @index += 1 }
  end
end

class Array
  def iterator
    Iterator.new(self)
  end
end
```

i ãŒæ¶ˆãˆãŸ

```ruby
it = ary.iterator
while it.has_next?
  p it.next
end
```

it ã‚‚æ¶ˆã™

```ruby
class Array
  def iterator
    it = Iterator.new(self)
    while it.has_next?
      yield it.next
    end
  end
end

%w(a b c).iterator { |e| p e }
# >> "a"
# >> "b"
# >> "c"
```

each ã¨ã»ã¼åŒã˜ã«ãªã£ãŸ

## Memento ##

ãƒ–ãƒ©ãƒƒã‚¯ã‚¸ãƒ£ãƒƒã‚¯ã‚’è¡Œã†ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼

```ruby
class Player
  attr_accessor :cards

  def initialize
    @cards = []
  end

  def take
    @cards << rand(1..13)
  end

  def score
    @cards.sum
  end
end
```

5å›ã‚«ãƒ¼ãƒ‰ã‚’å¼•ãã‚²ãƒ¼ãƒ ã‚’3å›è¡Œã†ã¨å…¨éƒ¨21ã‚’è¶Šãˆã¦ã—ã¾ã£ãŸ

```ruby
3.times do
  player = Player.new
  5.times { player.take }
  player.score                  # => 33, 37, 52
end
```

ãã“ã§ Memento ãƒ‘ã‚¿ãƒ¼ãƒ³

```ruby
class Player
  def create_memento
    @cards.clone
  end

  def restore_memento(object)
    @cards = object.clone
  end
end
```

21ç‚¹æœªæº€ã®çŠ¶æ…‹ã‚’ä¿æŒã—ã¦ãŠã21ã‚’è¶ŠãˆãŸã‚‰å…ƒã«æˆ»ã™

```ruby
3.times do
  player = Player.new
  memento = nil
  5.times do
    player.take
    if player.score < 21
      memento = player.create_memento
    elsif player.score > 21
      player.restore_memento(memento)
    end
  end
  player.score                  # => 18, 19, 15
end
```

memento ã«ã¯å¾©å…ƒã«å¿…è¦ãªã‚‚ã®ã ã‘å…¥ã‚Œã¨ã

## Visitor ##

```ruby
Pathname.glob("**/*.rb") { |f| }
```

## Flyweight ##

```ruby
module Sound
  @counter = 0

  class << self
    def get(key)
      @cache ||= {}
      @cache[key] ||= load("#{key}.mp3")
    end

    private

    def load(key)
      @counter += 1
    end
  end
end

Sound.get(:battle) # => 1
Sound.get(:battle) # => 1
```

## Builder ##

ãªã‚“ã‹æ±šã„

```ruby
class Node
  attr_reader :name, :nodes

  def initialize(name)
    @name = name
    @nodes = []
  end
end

root = Node.new("root")
root.nodes << Node.new("a")
root.nodes << Node.new("b")
root.nodes << (c = Node.new("c"))
c.nodes << Node.new("d")
c.nodes << Node.new("e")
c.nodes << (f = Node.new("f"))
f.nodes << Node.new("g")
f.nodes << Node.new("h")

root.nodes.collect(&:name)                       # => ["a", "b", "c"]
root.nodes.last.nodes.collect(&:name)            # => ["d", "e", "f"]
root.nodes.last.nodes.last.nodes.collect(&:name) # => ["g", "h"]
```

æ”¹å–„å¾Œ

```ruby
class Node
  def add(name, &block)
    tap do
      node = self.class.new(name)
      @nodes << node
      if block_given?
        node.instance_eval(&block)
      end
    end
  end
end

root = Node.new("root")
root.instance_eval do
  add "a"
  add "b"
  add "c" do
    add "d"
    add "e"
    add "f" do
      add "g"
      add "h"
    end
  end
end

root.nodes.collect(&:name)                       # => ["a", "b", "c"]
root.nodes.last.nodes.collect(&:name)            # => ["d", "e", "f"]
root.nodes.last.nodes.last.nodes.collect(&:name) # => ["g", "h"]
```

#### ä»–ã®ä¾‹ ####

AddressContainer ãªã‚“ã¦åˆ©ç”¨è€…ã«ã¨ã£ã¦ã¯çŸ¥ã‚‰ãªãã¦ã„ã„ã‚‚ã®

```ruby
class AddressContainer
  def initialize(address)
    @address = address
  end
end

class Mail
  attr_accessor :to
end

mail = Mail.new
mail.to = AddressContainer.new("alice <alice@example.net>")
```

æ”¹å–„å¾Œ

```ruby
class Mail
  attr_reader :to

  def to=(address)
    @to = AddressContainer.new(address)
  end
end

mail = Mail.new
mail.to = "alice <alice@example.net>"
```

## Facade ##

ã“ã‚“ãªã®ã‚’ã‚ã£ã¡ã“ã£ã¡ã«æ›¸ã‹ã›ã‚‹ã‚“ã˜ã‚ƒãªãã¦

```ruby
message = Message.new(date: Time.now)
message.from = User.find_by(name: "alice")
message.to   = User.find_by(name: "bob")
message.body = "..."
if message.valid?
  message.save!
end
MessageMailer.message_created(message).deliver_later
```

æ¬¡ã®ã‚ˆã†ã«ä½¿ã„ã‚„ã™ã„ãƒ¡ã‚½ãƒƒãƒ‰ã«ã—ã¨ã‘ã£ã¦ã“ã¨ã‹ãªï¼Ÿ

```ruby
Message.deliver(from: "alice", to: "bob", body: "...")
```

## Bridge ##

æ©Ÿèƒ½ã¨å®Ÿè£…ã®éšå±¤ã‚’åˆ†ã‘ã‚‹ã£ã¦è¨€ã£ã¦ã‚‚ Strategy ã¨ä½•ãŒé•ã†ï¼Ÿ
è¦ã¯ DRY ã«ã—ã¨ã‘ã°æ‹¡å¼µãŒæ¥½ã¡ã‚“ã¨ã„ã†ã“ã¨ã‚‰ã—ã„
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ x y ã®å®Ÿè£…2ã¤ã¨ã€å›²ã¾ãªã„å›²ã‚€ã®2ã¤ã®æ©Ÿèƒ½ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã¨2x2ã§4ã¤ã®ã‚¯ãƒ©ã‚¹ãŒå¿…è¦ã«ãªã‚‹
ã“ã®ã¾ã¾æ‹¡å¼µã—ã¦ã„ã£ã¦å®Ÿè£…ã¨æ©Ÿèƒ½ãŒãã‚Œãã‚Œ10å€‹ã‚ã‚‹ã¨100å€‹ã®ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‰ãªã„ã¨ã„ã‘ãªããªã‚‹

```ruby
class A
  def run
    "x"
  end
end

class B
  def run
    "y"
  end
end

class AA < A
  def run
    "(x)"
  end
end

class BB < B
  def run
    "(y)"
  end
end
```

æ”¹å–„

```ruby
class A
  def initialize(obj)
    @obj = obj
  end

  def run
    @obj
  end
end

class AA < A
  def run
    "(#{@obj})"
  end
end
```

## Decorator ##

Proxy ã«ä¼¼ã¦ã„ã‚‹ã‘ã©é…å»¶å®Ÿè¡Œã‚„å®Ÿè¡Œæ¡ä»¶ã«ã¯é–¢å¿ƒãŒãªã„

```ruby
require "delegate"

class User
  def name
    "alice"
  end
end

class UserDecorator < SimpleDelegator
  def to_xxx
    "(#{name})"
  end
end

UserDecorator.new(User.new).to_xxx # => "(alice)"
```

## Observer ##

Subject ã‹ã‚‰ã®ä¸€æ–¹é€šè¡Œã§ãªã„ã¨ã„ã‘ãªã„
ãŸã¾ã«æˆ»å€¤ãŒæ¬²ã—ããªã‚‹å ´åˆãŒã‚ã‚‹ã‘ã©ã€ãã‚Œã¯ã‚‚ã† Observer ã§ã¯ãªã Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³ãªã©ã‚’æ¤œè¨ã—ãŸæ–¹ãŒã„ã„
Observer å´ã« player (Subject) ã‚’æ¸¡ã—ã¦ player.add_observer(self) ã¯ã€ã¾ã‚ã‚Šãã©ã„ã®ã§è‡ªåˆ†ã¯ã‚„ã‚‰ãªã„
Observer ã« player ã‚’æ¡ã‚‰ã›ãŸã‚‰ Component Bus ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãªã‚‹ã£ã½ã„

å¯†çµåˆçŠ¶æ…‹ã‚’

```ruby
class Player
  def initialize
    @foo = Foo.new
    @bar = Bar.new
  end

  def notify
    if @foo
      @foo.update(self)
    end
    if @bar
      @bar.update(self)
    end
  end
end
```

è§£æ¶ˆ

```ruby
class Player
  attr_accessor :observers
  def initialize
    @observers = []
  end

  def notify
    @observers.each do |observer|
      observer.update(self)
    end
  end
end

player = Player.new
player.observers << Foo.new
player.observers << Bar.new
```

### æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†ã¨ç°¡æ½”ã«ãªã‚‹ ###

```ruby
require "observer"

class Player
  include Observable

  def notify
    changed
    notify_observers(self)
  end
end

player = Player.new
player.add_observer(Foo.new)
player.add_observer(Bar.new)
player.notify
```

ã™ãã« Observer ã‚¯ãƒ©ã‚¹ã‚’ç”¨æ„ã™ã‚‹å¿…è¦ã¯ãªãè‡ªåˆ†ã‚’ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã«ã—ã¦ã‚‚ã„ã„

```ruby
require "observer"
class Player
  include Observable

  def initialize
    add_observer(self)
  end

  def notify
    changed
    notify_observers(self)
  end

  def update(player)
    player # => #<Player:0x007ff9098472e0 ...>
  end
end

player = Player.new
player.notify
```

## Component Bus ##

Observer ãŸã¡ãŒãƒ‡ãƒ¼ã‚¿å…±æœ‰ã—ãŸã„ã®ã§ Subject ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã«ã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³

```ruby
class Player
  include Observable

  attr_accessor :data

  def notify
    changed
    notify_observers
  end
end

class Display
  def initialize(player)
    player.add_observer(self)
    @player = player    # Subjectã‚’æ¡ã£ã¦ã„ã‚‹
  end

  def update
  end

  def data
    @player.data
  end
end
```

æ±ç”¨æ€§ã®ã‚ã£ãŸ Observer ãŒ Subject ä¾å­˜ã«ãªã‚‹ãƒ‡ãƒ¡ãƒªãƒƒãƒˆã‚‚è€ƒæ…®ã™ã‚‹ã“ã¨

## Singleton ###

ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¯æ‚ªã¨è¨€ã†ãŒä¸€å¿œã‚¯ãƒ©ã‚¹ã ã‹ã‚‰ã‚®ãƒªã‚»ãƒ¼ãƒ•ã¨ã„ã†ã“ã¨ã«ã—ãŸã„å„ªæŸ”ä¸æ–­ãªäººã®ãŸã‚ã®ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³

```ruby
class C
  private_class_method :new
  def self.instance
    @instance ||= new
  end
end

C.instance # => #<C:0x007f98e404a518>
C.instance # => #<C:0x007f98e404a518>
```

æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã£ãŸå ´åˆ

```ruby
require "singleton"

class C
  include Singleton
end

C.instance # => #<C:0x007f98e509f558>
C.instance # => #<C:0x007f98e509f558>
```

ãã“ã¾ã§ãã°ã‚‰ãªãã¦ã‚‚æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã§å……åˆ†ãªã“ã¨ã‚‚å¤šã„

```ruby
module M
  extend self

  def foo
  end
end
```

## Strategy ##

```ruby
class LegalDice
  def next
    rand(1..6)
  end
end

class CheatDice
  def next
    6
  end
end

class Player
  def initialize(dice)
    @dice = dice
  end

  def roll
    10.times.collect { @dice.next }
  end
end

Player.new(LegalDice.new).roll  # => [4, 4, 5, 4, 5, 2, 4, 2, 2, 4]
Player.new(CheatDice.new).roll  # => [6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
```

  * Player ã®ã‚³ãƒ¼ãƒ‰ã¯ãã®ã¾ã¾ã§ã‚µã‚¤ã‚³ãƒ­ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
  * State ã¨ä¼¼ã¦ã„ã‚‹ãŒå†…éƒ¨ã§åˆ‡ã‚Šæ›¿ãˆã‚‹ã®ã§ã¯ãªãåˆ©ç”¨è€…ãŒæ„è­˜ã—ã¦å¤–ã‹ã‚‰æ¸¡ã™
  * Player ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã†åˆ©ç”¨è€…ã¯ LegalDice ã‚„ CheatDice ã®ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹

## State ##

```ruby
class OpenState
  def board
    "å–¶æ¥­ä¸­"
  end
end

class CloseState
  def board
    "æº–å‚™ä¸­"
  end
end

class Shop
  def change_state(hour)
    if (11..17).include?(hour)
      @state = OpenState.new
    else
      @state = CloseState.new
    end
  end

  def board
    @state.board
  end
end

shop = Shop.new
shop.change_state(10)
shop.board                      # => "æº–å‚™ä¸­"
shop.change_state(11)
shop.board                      # => "å–¶æ¥­ä¸­"
```

  * Strategy ã¨ä¼¼ã¦ã„ã‚‹ãŒå†…éƒ¨ã§ä½¿ã†ã ã‘
  * Shop ã‚¯ãƒ©ã‚¹ä½¿ã†åˆ©ç”¨è€…ã¯ OpenState CloseState ã®ã“ã¨ã‚’çŸ¥ã‚‰ãªã„

## Adapter

```ruby
class C
  def f1
    "x"
  end
end
```

    ç¶™æ‰¿ç‰ˆ

```ruby
class C2 < C
  def f2
    f1 * 2
  end
end
```

    å§”è­²ç‰ˆ

```ruby
class C3
  def initialize
    @c = C.new
  end

  def f1
    @c.f1
  end

  def f2
    f1 * 2
  end
end
```

    f1 ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ›¸ãã®ãŒé¢å€’ãªã¨ã

```ruby
require "delegate"

class C4 < SimpleDelegator
  def initialize
    super(C.new)
  end

  def f2
    f1 * 2
  end
end
```

```ruby
[C2.new.f1, C2.new.f2]      # => ["x", "xx"]
[C3.new.f1, C3.new.f2]      # => ["x", "xx"]
[C4.new.f1, C4.new.f2]      # => ["x", "xx"]
```

### Factory Method ã ã¨æ€ã£ã¦ã„ãŸã‚‰ Adapter ã ã£ãŸã‚‚ã® ###

ã“ã†ã„ã†ã®ã¯ã‚ã£ã¨ã‚†ã†ã¾ã« search ãƒ¡ã‚½ãƒƒãƒ‰ãŒè‚¥å¤§åŒ–ã™ã‚‹
ã§ã€User ã‚¯ãƒ©ã‚¹å†…ã§ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã—ã¦åˆ†é›¢ã™ã‚‹ã¨ã„ã†*é–“é•ã£ãŸãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°*ã‚’è¡Œã£ã¦ã—ã¾ã„ãŒã¡
ãã†ã™ã‚‹ã¨ä»–ã®ã‚¯ãƒ©ã‚¹ãƒ¡ã‚½ãƒƒãƒ‰ã¨å¹²æ¸‰ã—ã¦ç ´ç¶»ã™ã‚‹

```ruby
class User
  def self.search(query)
    ["name like ?", "%#{query}%"]
  end
end

User.search("alice") # => ["name like ?", "%alice%"]
```

ãã†ãªã‚Šãã†ãªã‚‰æ¬¡ã®ã‚ˆã†ã«æ”¹å–„ã™ã‚‹

```ruby
class User
  def self.search(...)
    Search.new(self, ...).run
  end
end

class Search
  def initialize(model, query)
    @model = model
    @query = query
  end

  def run
    ["name like ?", "%#{@query}%"]
  end
end

User.search("alice")   # => ["name like ?", "%alice%"]
```

Search ã‚¯ãƒ©ã‚¹ã®ä¸­ã§ã„ãã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å¢—ã‚„ã—ã¦ã‚‚å…ƒã® User ã«ã¯å½±éŸ¿ãŒãªã„

æ¬¡ã¯ä¾‹ãŒã„ã¾ã„ã¡ã ã‘ã© @color ã‹ã‚‰å¤‰æ›ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ Player è‡ªä½“ã«å…¥ã‚Œã¦ã—ã¾ã£ã¦ Player ã‚¯ãƒ©ã‚¹ãŒã‚«ã‚ªã‚¹ã«ãªã£ã¦ã—ã¾ã†ã‚±ãƒ¼ã‚¹

```ruby
class Player
  def initialize
    @color_key = :blue
  end
end
```

ã“ã“ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è‰²ã‚’ `#00F` ã§è¿”ã—ãŸã‹ã£ãŸã®ã§ rgb ãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã—ãŸ
ã“ã‚ŒãŒãƒ€ãƒ¡

```ruby
class Player
  def rgb
    "#00F"
  end
end
```

æ”¹å–„å¾Œ

```ruby
class Color
  def initialize(...)
  end

  def rgb
    "#00F"
  end
end

class Player
  def color
    Color.new(@color_key)
  end
end

player.color.rgb # => "#00F"
```

ã“ã†ã™ã‚Œã°ã„ãã‚‰ã§ã‚‚çª®å±ˆãªçŠ¶æ…‹ã‹ã‚‰è„±å‡ºã§ãã‚‹
ã‚‚ã— "é’" ãŒæ¬²ã—ã‘ã‚Œã° Color ã«è¶³ã™

```ruby
class ColorInfo
  def name
    "é’"
  end
end

player.color.name # => "é’"
```

## Interpreter ##

ã‚·ãƒ³ãƒ—ãƒ«ãªDSL

```ruby
class Expression
end

class Value < Expression
  attr_accessor :value
  def initialize(value)
    @value = value
  end

  def evaluate
    "mov  ax, #{@value}"
  end
end

class Add < Expression
  def initialize(left, right)
    @left, @right = left, right
  end

  def evaluate
    [
      @left.evaluate,
      "mov  dx, ax",
      @right.evaluate,
      "add  ax, dx",
    ]
  end
end

def ADD(l, r)
  Add.new(Value.new(l), Value.new(r))
end

expr = ADD 1, 2
puts expr.evaluate
# >> mov  ax, 1
# >> mov  dx, ax
# >> mov  ax, 2
# >> add  ax, dx
```

## Typed Message ##

GUI ã‚¢ãƒ—ãƒªã§ã‚¤ãƒ™ãƒ³ãƒˆãŒèµ·ãã‚‹ã¨ã„ã‚ã‚“ãªã‚‚ã®ãŒé£›ã‚“ã§ãã¦ç¾ã—ããªã„ switch æ–‡ãŒã§ãã¦ã—ã¾ã†ã‚ã‚Œã®ã“ã¨

```ruby
class MouseMotion
end

class App
  def receive(e)
    case e
    when MouseMotion
    end
  end
end

app = App.new
app.receive(MouseMotion.new)
```

## Cache Manager

    http://www002.upp.so-net.ne.jp/ys_oota/mdp/CacheManager/index.htm å‚ç…§

```ruby
class Cache
  attr_accessor :max, :pool

  def initialize
    @max = 2
    @pool = []
  end

  def fetch(key)
    v = nil
    if index = @pool.find_index { |e| e[:key] == key }
      v = @pool.slice!(index)[:val]
    else
      v = yield
    end
    @pool = ([key: key, val: v] + @pool).take(@max)
    v
  end
end

cache = Cache.new
cache.fetch(:a) { 1 }           # => 1
cache.pool                      # => [{:key=>:a, :val=>1}]
cache.fetch(:b) { 1 }           # => 1
cache.pool                      # => [{:key=>:b, :val=>1}, {:key=>:a, :val=>1}]
cache.fetch(:a) { 2 }           # => 1
cache.pool                      # => [{:key=>:a, :val=>1}, {:key=>:b, :val=>1}]
cache.fetch(:c) { 1 }           # => 1
cache.pool                      # => [{:key=>:c, :val=>1}, {:key=>:a, :val=>1}]
```

a b ã§ pool ã¯ b a ã®é †ã«ãªã‚Šã€æ¬¡ã® a ã§ a b ã«ãªã‚Šã€æ¬¡ã® c ã§ c a b ã«ãªã‚‹ã€‚
ãŒã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºã¯ 2 ãªã®ã§ b ãŒæ­»ã‚“ã§ c a

# ã‚¹ãƒ¬ãƒƒãƒ‰ç”¨ #

## Single Threaded Execution ##

æ’ä»–åˆ¶å¾¡ã®ã“ã¨

```ruby
mutex = Mutex.new
a = 0
b = 0
2.times.collect {
  Thread.start do
    2.times do
      mutex.synchronize do
        a += 1
        Thread.pass
        b += 1
        p [a, b, (a == b)]
      end
    end
  end
}.each(&:join)
# >> [1, 1, true]
# >> [2, 2, true]
# >> [3, 3, true]
# >> [4, 4, true]
```

æ˜ç¤ºçš„ã«ãƒ‘ã‚¹ã—ã¦ã‚‚ synchronize ãƒ–ãƒ­ãƒƒã‚¯å†…ã¯ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåˆ‡ã‚Šæ›¿ã‚ã‚‰ãªã„ã“ã¨ãŒã‚ã‹ã‚‹

## Immutable ##

ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰å‚ç…§ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…å®¹ãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãªã‚‰æ’ä»–åˆ¶å¾¡ãŒå¿…è¦ã ã‘ã©ã€ãã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒä¸å¤‰(ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«)ãªã‚‰ã°æ’ä»–åˆ¶å¾¡ãŒå¿…è¦ãŒãªã„ã¨ã„ã†ã“ã¨ã€‚ãŸã¶ã‚“ã€‚
Javaã®æœ¬ã ã¨ã‚»ãƒƒã‚¿ãƒ¼ãŒãªã„ã‚‚ã®ã¨æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‘ã©ã€Ruby ã®å ´åˆã¯ reader ã‹ã‚‰ replace ã™ã‚Œã°æ›¸ãæ›ãˆã‚‰ã‚Œã‚‹ã®ã§æ°—æŒã¡ç¨‹åº¦ã« freeze ã—ã¦ã¿ãŸã€‚

```ruby
class C
  attr_reader :v
  def initialize(v)
    @v = v
    @v.freeze
  end
end

a = C.new("x").freeze
a.v.replace("y") rescue $! # => #<RuntimeError: can't modify frozen String>
a.v += "y" rescue $!       # => #<NoMethodError: undefined method `v=' for #<C:0x007fbfc3903910 @v="x">>
a.v                        # => "x"
```

## Guarded Suspension - å®Ÿè¡Œã§ãã‚‹ã¾ã§å¾…ã¤ ##

```ruby
queue = Queue.new

send_num = 10

sender = Thread.start do
  Thread.current[:data] = []
  send_num.times do |i|
    sleep(rand(0..0.01))
    queue << i
    Thread.current[:data] << i
  end
end

receiver = Thread.start do
  Thread.current[:data] = []
  send_num.times do
    sleep(rand(0..0.001))
    # popå‡ºæ¥ãªã„ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ãŒè‡ªå‹•åœæ­¢ã—ã¦ãã‚Œã‚‹ã€‚popã ã‘ã©FIFOã€‚é–“é•ã„ãã†ã€‚
    Thread.current[:data] << queue.pop
  end
end

sender.join
receiver.join

# æ­£å¸¸ã«ãƒ‡ãƒ¼ã‚¿ãŒå—ã‘å–ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
sender[:data]   # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
receiver[:data] # => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## Worker Thread - ä»•äº‹ãŒãã‚‹ã¾ã§å¾…ã¡ä»•äº‹ãŒããŸã‚‰åƒã ##

```ruby
class Channel < SizedQueue
  attr_reader :threads

  def initialize(size)
    super(size)
    @threads = size.times.collect do |i|
      Thread.start(i) do |i|
        loop do
          request = pop
          p "ã‚¹ãƒ¬ãƒƒãƒ‰#{i}ãŒ#{request}ã‚’æ‹…å½“"
          sleep(1)
        end
      end
    end
  end
end

# 1ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã ã‘ã ã¨ 3.3 ç§’ã€‚
# 4ç§’ã«ãªã£ã¦ãªã„ã®ã¯ã€ãŸã¶ã‚“æœ€å¾Œã® sleep(1) ãŒé–‹å§‹ã—ãŸæ™‚ç‚¹ã§ status == "sleep" ã«ãªã£ã¦ã‚‹ã‹ã‚‰ã¿ãŸã„
channel = Channel.new(1)
t = Time.now
4.times { |i| channel << i }
nil until channel.size.zero? && channel.threads.all? { |t| t.status == "sleep" }
puts "%.1f s" % (Time.now - t)
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰0ãŒ0ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰0ãŒ1ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰0ãŒ2ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰0ãŒ3ã‚’æ‹…å½“"
# >> 3.1 s

# 4ã¤ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã ã¨å‡¦ç†ãŒåˆ†æ•£ã—ã¦ã™ãçµ‚ã‚ã‚‹
channel = Channel.new(4)
t = Time.now
4.times { |i| channel << i }
nil until channel.size.zero? && channel.threads.all? { |t| t.status == "sleep" }
puts "%.1f s" % (Time.now - t)
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰0ãŒ0ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰1ãŒ1ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰2ãŒ2ã‚’æ‹…å½“"
# >> "ã‚¹ãƒ¬ãƒƒãƒ‰3ãŒ3ã‚’æ‹…å½“"
# >> 0.1 s
```

## Balking (ãƒœãƒ¼ã‚­ãƒ³ã‚°) - å®Ÿè¡Œã§ãã‚‹ã¾ã§å¾…ãŸãªã„

    å¾…ã¤ã®ã§ã¯ãªãã€ã™ãã« *ãƒªã‚¿ãƒ¼ãƒ³* ã™ã‚‹ã€‚å¾…ã¤å ´åˆã¯ Guarded Suspention ã«ãªã‚‹ã€‚
    ä¸€ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãä¸€éƒ¨ã ã‘æ’ä»–åˆ¶å¾¡ã‚’è¡Œã†ã«ã¯ synchronize ãƒ–ãƒ­ãƒƒã‚¯ã§å›²ã‚€ã€‚

    ä»¥ä¸‹ã®ä¾‹ã¯ a b c ã‚’é †ç•ªã«ç™ºå‹•ã—ã¦ã„ãã€‚
    ãŸã  a ã®å‡¦ç†ãŒ 0.1 ç§’ã‹ã‹ã£ã¦ã„ã‚‹ãŸã‚ã€ç›´å¾Œã«ç™ºå‹•ã—ãŸ b ã¯ a ãŒå‡¦ç†ä¸­ã®ãŸã‚ãƒªã‚¿ãƒ¼ãƒ³ã—ã¦ã„ã‚‹ã€‚
    aã®å‡¦ç†ãŒçµ‚ã‚ã£ãŸã“ã‚ã«ç™ºå‹•ã—ãŸ c ã¯å®Ÿè¡Œã§ãã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚

```ruby
class C
  include Mutex_m

  def initialize
    super
    @change = false
  end

  def execute(str, t)
    synchronize do
      if @change
        p "å‡¦ç†ä¸­ã®ãŸã‚#{str}ã¯ã‚¹ã‚­ãƒƒãƒ—"
        return
      end
      @change = true

      p str
      sleep(t) # sleepã¯synchronizeã®ä¸­ã§è¡Œã‚ãªã„ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹

      @change = false
    end
  end
end

x = C.new
threads = []
threads << Thread.start {x.execute("a", 0.1)}
threads << Thread.start {x.execute("b", 0)}
sleep(0.1)
threads << Thread.start {x.execute("c", 0)}
threads.collect(&:join)
# >> "a"
# >> "å‡¦ç†ä¸­ã®ãŸã‚bã¯ã‚¹ã‚­ãƒƒãƒ—"
# >> "c"
```

## Thread Per Message - æˆ»å€¤ä¸è¦

```ruby
def request(x)
  Thread.start(x){|x|p x}
end

request("a")
request("b")

(Thread.list - [Thread.main]).each(&:join)
# >> "a"
# >> "b"
```

## Future - æˆ»å€¤å¿…è¦

```ruby
def request(x)
  Thread.start(x){|x|x}
end

t = []
t << request("A")
t << request("B")
t.collect(&:value) # => ["A", "B"]
```

## Producer Consumer

    ç”Ÿç”£ã‚¹ãƒ¬ãŒä½œã£ã¦ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã¦ä½¿ç”¨ã‚¹ãƒ¬ãŒpopã™ã‚‹ã€‚
    SizedQueueã®ã‚µã‚¤ã‚ºã®å°ã•ã„ã»ã©æµã‚ŒãŒæ‚ªããªã‚‹ã€‚
    ä»¥ä¸‹ã®ä¾‹ã¯SizedQueueã®ã‚µã‚¤ã‚ºãŒ1ã—ã‹ãªã„ã®ã§consumerãŒpopã—ã¦ãã‚Œãªã„ã¨æ¬¡ã‚’pushã§ããªã„ã€‚

```ruby
queue = SizedQueue.new(1)
producer = Thread.start {
  4.times {|i|
    p ["ä½œæˆ", i]
    queue.push(i)
  }
  p "ä½œæˆå´ã¯å…ˆã«çµ‚äº†"
}
consumer = Thread.start {
  4.times {
    p ["ä½¿ç”¨", queue.pop]
    sleep(0.01)
  }
}
producer.join
consumer.join
# >> ["ä½œæˆ", 0]
# >> ["ä½œæˆ", 1]
# >> ["ä½¿ç”¨", 0]
# >> ["ä½œæˆ", 2]
# >> ["ä½¿ç”¨", 1]
# >> ["ä½œæˆ", 3]
# >> ["ä½¿ç”¨", 2]
# >> "ä½œæˆå´ã¯å…ˆã«çµ‚äº†"
# >> ["ä½¿ç”¨", 3]
```

## Read Write Lock

```ruby
class Buffer
  def initialize
    @sync = Sync.new
    @str = ""
  end

  def write(_str)
    @sync.synchronize(:EX) do
      _str.chars.with_index do |c, i|
        sleep(0.0001)
        @str[i] = c
      end
    end
  end

  def read
    @sync.synchronize(:SH) do
      @str.size.times.collect {|i|
        sleep(0.001)
        @str[i]
      }.join
    end
  end
end
```

    æ›¸ãè¾¼ã¿ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã€èª­ã¿è¾¼ã¿ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä¸¦åˆ—ã§èµ·å‹•ã—ã¦ã€ãŠäº’ã„ãŒå¹²æ¸‰ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹

```ruby
buffer = Buffer.new
w = Thread.start do
  ("A".."Z").cycle {|c|
    buffer.write(c.to_s * 64)
    sleep(0.001)
  }
end
r = Thread.start do
  10.times do
    sleep(0.001)
    p buffer.read
  end
end
r.join
w.kill
```

    ã§ã‚‚çµæœã¯å£Šã‚Œã¦ãªã„

```ruby
# >> "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
# >> "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"
# >> "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"
# >> "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
# >> "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE"
# >> "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
# >> "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG"
# >> "HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH"
# >> "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII"
# >> "JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ"
```

    @sync.synchronize ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ã‚ãªã‹ã£ãŸå ´åˆ

```ruby
# >> AAAAAAA
# >> BBBBBBBBBBCCCCCCCCCCCDDDDDDDDDDDEEEEEEEEEEEFFFFFFFFFFGGGGGGGGGGG
# >> IIIIIIIIIIJJJJJJJJJJJKKKKKKKKKKKLLLLLLLLLLMMMMMMMMMMMNNNNNNNNNNO
# >> PPPPPPPPPPQQQQQQQQQQQRRRRRRRRRRRSSSSSSSSSSTTTTTTTTTTTUUUUUUUUUUU
# >> WWWWWWWWWWXXXXXXXXXXXYYYYYYYYYYYYZZZZZZZZZZAAAAAAAAAAABBBBBBBBBB
# >> DDDDDDDDDDDEEEEEEEEEEEEFFFFFFFFFFFGGGGGGGGGGHHHHHHHHHHHIIIIIIIII
# >> JJKKKKKKKKKKKLLLLLLLLLLLMMMMMMMMMMNNNNNNNNNNNOOOOOOOOOOOPPPPPPPP
# >> QQRRRRRRRRRRRSSSSSSSSSSTTTTTTTTTTTUUUUUUUUUUVVVVVVVVVVVWWWWWWWWW
# >> XXYYYYYYYYYYYZZZZZZZZZZZAAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCCDDDDDDD
# >> EEEEFFFFFFFFFFFGGGGGGGGGGGHHHHHHHHHHHIIIIIIIIIIIJJJJJJJJJJJKKKKK
```

## Two Phase Termination

    å¤–ã‹ã‚‰ Thread.kill ã™ã‚‹ã‚“ã˜ã‚ƒãªãã¦æ­¢ã¾ã‚‹ã‚ˆã†ã«æŒ‡ç¤º

```ruby
t = Thread.start do
  2.times do |i|
    if Thread.current["interrupt"]
      break
    end
    p "å‡¦ç†ä¸­: #{i}"
    sleep(0.2)
  end
  p "çµ‚äº†å‡¦ç†"
end
sleep(0.1)
t["interrupt"] = true
t.join
# >> "å‡¦ç†ä¸­: 0"
# >> "çµ‚äº†å‡¦ç†"
```

## Thread Specific Storage

    Thread.current["a"] ã¯ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°

```ruby
Thread.start { Thread.current["a"] = 1 }.join
Thread.start { Thread.current["a"] }.value    # => nil
```

## ãã®ä»–

## Active Object - éåŒæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚‹

    ã©ã‚“ãªã¨ãã«æœ‰ç”¨ã‹ï¼Ÿ

```ruby
class C
  def process
    1 + 2
  end
end

obj = C.new
obj.process
```

    ã“ã“ã§ã€ã™ãã«å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒãªã„ 1 + 2 ã®å‡¦ç†ãŒé‡ã™ãã‚‹å ´åˆã€

```ruby
class C
  attr_accessor :queue

  def initialize
    @queue = Queue.new
    Thread.start do
      loop { @queue.pop.call }  # ãƒãƒƒã‚¯ã‚°ãƒ©ãƒ³ãƒ‰å‡¦ç†ã‚’æ°¸é ã¨å›ã™
    end
  end

  def process
    @queue << proc {p 1 + 2}
  end
end

obj = C.new
obj.process

nil until obj.queue.empty?
```

    C#process ã®ä¸­ã®å‡¦ç†ãŒå¤‰ã‚ã£ãŸã ã‘ã§ *ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã¯ãã®ã¾ã¾*

## Before / After

```ruby
begin
  p "before"
  1 / 0
rescue => error
  p error
ensure
  p "after"
end
# >> "before"
# >> #<ZeroDivisionError: divided by 0>
# >> "after"
```

## Pluggable Selector

    ã‚ˆãã‚ã‹ã£ã¦ãªã„ã€‚
    ä¸€ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå·¨å¤§åŒ–ã—ãã†ãªã¨ãã¨ã‹ã«ã€åˆ¥ã®ã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹ã®ãŒé¢å€’ã¨ã„ã†ç†ç”±ã§ä¼¼ãŸã‚ˆã†ãªæ›¸ãæ–¹ã‚’ã—ã¦ã—ã¾ã†ã€‚
    ã©ã†ãªã‚“ã ã‚ã†ï¼Ÿ

```ruby
class C
  def initialize(command)
    @command = command
  end

  def execute
    send(@command)
  end

  def command_x
    :a
  end
end

C.new(:command_x).execute       # => :a
```

## Object Pool

ãƒ¡ãƒ¢åŒ–ã¨ã„ã†ã‚ˆã‚Šãƒ¡ãƒ¢ãƒªã¨é€Ÿåº¦ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•ã€‚

```ruby
class X
  attr_accessor :active
end

class C
  attr_accessor :pool

  def initialize
    @size = 2
    @pool = []
  end

  def new_x
    x = @pool.find {|e|!e.active}  # pool ã‹ã‚‰ç¨¼åƒã—ã¦ãªã„ã‚‚ã®ã‚’æ¢ã™
    unless x                      # ãªã‘ã‚Œã°
      if @pool.size < @size       # pool ã®ç©ºããŒã‚ã‚Œã°ã€æ–°ãŸã«ä½œæˆ
        x = X.new
        @pool << x
      end
    end
    if x
      x.active = true
    end
    x
  end
end

i = C.new
a = i.new_x                  # => #<X:0x007fd1cb08d5c8 @active=true>
b = i.new_x                  # => #<X:0x007fd1cb08d140 @active=true>
c = i.new_x                  # => nil
a.active = false
c = i.new_x                  # => #<X:0x007fd1cb08d5c8 @active=true>
```

## Null Object

```ruby
class Logger
  def info(str)
    str
  end
end

logger = Logger.new
logger.info("x")                # => "x"
```

logger ã‚’ç„¡åŠ¹ã«ã™ã‚‹

```ruby
class NullObject
  def info(str)
  end
end
```

```ruby
logger = NullObject.new
logger.info("x")                # => nil
```

å¯Œè±ªçš„ãªæ„ŸãŒã‚ˆã„
