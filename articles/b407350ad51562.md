---
title: "[Rust] ベクトルライブラリ glam の作り込みがやばかった"
emoji: "🦔"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rust", "glam", "nannou"]
published: false
---

## はじめに

[nannou](https://docs.rs/nannou) で使われている [glam](https://docs.rs/glam) というベクトルライブラリの作り込みがすさまじかったので、2Dグラフィックスを扱うときに主に使うと思われる Vec2 型を中心に(自分が使い方を覚えるために)使い方を紹介する。

## 基本的な生成方法

```rust
vec2(2.0, 3.0)        // => Vec2(2.0, 3.0)
Vec2::new(2.0, 3.0)); // => Vec2(2.0, 3.0)

// 全要素を同じ値で生成する
Vec2::splat(2.0)      // => Vec2(2.0, 2.0)
```

## 他の型からの生成

```rust
// from は似たような型ならなんでもいける
Vec2::from((2.0, 3.0))               // => Vec2(2.0, 3.0)
Vec2::from([2.0, 3.0])               // => Vec2(2.0, 3.0)
Vec2::from(vec2(2.0, 3.0))           // => Vec2(2.0, 3.0)
Vec2::from(Vec3::new(2.0, 3.0, 4.0)) // => Vec2(2.0, 3.0)

// 配列の参照から生成
Vec2::from_slice(&[2.0, 3.0])        // => Vec2(2.0, 3.0)
```

## 型変換系
```rust
// 3次元のベクトルに拡張する
vec2(2.0, 3.0).extend(4.0)     // => Vec3(2.0, 3.0, 4.0)

// 逆に3次元のベクトルから2次元に戻す
vec3(2.0, 3.0, 4.0).truncate() // => Vec2(2.0, 3.0)

// 精度を変更する (D=f64 I=i32 U=u32)
vec2(2.0, 3.0).as_f64()        // => DVec2(2.0, 3.0)
vec2(2.0, 3.0).as_i32()        // => IVec2(2, 3)
vec2(2.0, 3.0).as_u32()        // => UVec2(2, 3)

// ただの配列に戻す
vec2(2.0, 3.0).to_array()      // => [2.0, 3.0]

// 文字列化
vec2(2.0, 3.0).to_string()     // => "[2, 3]"
```

## あるある演算
```rust
        // vec2(2.0, 3.0).add(vec2(4.0, 5.0))     // => Vec2(3.0, 4.0)
vec2(2.0, 3.0) + 1.0     // => Vec2(3.0, 4.0)
vec2(2.0, 3.0) - 1.0     // => Vec2(1.0, 2.0)
vec2(2.0, 3.0) * 2.0     // => Vec2(4.0, 6.0)
vec2(2.0, 3.0) / 2.0     // => Vec2(1.0, 1.5)

vec2(2.0, 3.0) + vec2(4.0, 5.0) // => Vec2(6.0, 8.0)
vec2(2.0, 3.0) - vec2(4.0, 5.0) // => Vec2(-2.0, -2.0)
vec2(2.0, 3.0) * vec2(4.0, 5.0) // => Vec2(8.0, 15.0)
vec2(2.0, 3.0) / vec2(4.0, 5.0) // => Vec2(0.5, 0.6)

vec2(2.0, 3.0).powf(2.0) // => Vec2(4.0, 9.0)

vec2(2.0, 3.0).exp()     // => Vec2(7.389056, 20.085537)
-vec2(2.0, 3.0)          // => Vec2(-2.0, -3.0)
```

## 微補正
```rust
vec2(2.4, 3.5).floor() // => Vec2(2.0, 3.0)
vec2(2.4, 3.5).ceil()  // => Vec2(3.0, 4.0)
vec2(2.4, 3.5).round() // => Vec2(2.0, 4.0)
```

## 範囲補正
```rust
vec2(2.0, 5.0).clamp(vec2(3.0, 3.0), vec2(4.0, 4.0))   // => Vec2(3.0, 4.0)
```

## 成分を調整した変換
```rust
        // 絶対値にする
vec2(-2.0, -3.0).abs() // => Vec2(2.0, 3.0)

        // 符号だけにする
vec2(-2.0, 3.0).signum() // => Vec2(-1.0, 1.0)

        // 成分から成分の floor を引く
        // -2.4 - -3 → 0.6
        //  5.8 -  5 → 0.8
vec2(-2.4, 5.8).fract() // => Vec2(0.5999999, 0.8000002)
```

## 有限・無限(NAN?)
```rust
vec2(2.0, 3.0).is_finite() // => true

vec2(2.0, f32::NAN).is_nan()      // => true
vec2(2.0, f32::NAN).is_nan_mask() // => BVec2(0x0, 0xffffffff)
```

## 最大最小
```rust
        // 単に成分が対象
vec2(2.0, 3.0).min_element() // => 2.0
vec2(2.0, 3.0).max_element() // => 3.0
```

## 最大最小を取って合成
```rust
        // (x.max(other.x), y.max(other.y))
        // (x.min(other.x), y.min(other.y))
vec2(1.0, 2.0).max(vec2(3.0, 1.0)) // => Vec2(3.0, 2.0)
vec2(1.0, 2.0).min(vec2(3.0, 1.0)) // => Vec2(1.0, 1.0)
```

## 比較
```rust
        // 小数の誤差があるため整数のときだけにした方がよい
vec2(2.0, 3.0) == vec2(2.0, 3.0) // => true
vec2(2.0, 3.0) != vec2(4.0, 5.0) // => true
        // 大なり・小なりはできない

        // 許容する誤差を指定できる
vec2(2.0, 3.0).abs_diff_eq(vec2(2.0, 3.1), 0.09) // => false
vec2(2.0, 3.0).abs_diff_eq(vec2(2.0, 3.1), 0.1)  // => true
```

## 比較した結果を mask で返す
```rust
vec2(2.0, 3.0).cmpeq(vec2(2.0, 3.0)) // => BVec2(0xffffffff, 0xffffffff)
vec2(2.0, 3.0).cmpne(vec2(2.0, 3.0)) // => BVec2(0x0, 0x0)
vec2(2.0, 3.0).cmpge(vec2(2.0, 3.0)) // => BVec2(0xffffffff, 0xffffffff)
vec2(2.0, 3.0).cmpgt(vec2(2.0, 3.0)) // => BVec2(0x0, 0x0)
vec2(2.0, 3.0).cmple(vec2(2.0, 3.0)) // => BVec2(0xffffffff, 0xffffffff)
vec2(2.0, 3.0).cmplt(vec2(2.0, 3.0)) // => BVec2(0x0, 0x0)
```

## 長さ・距離
```rust
        // sqrt(x**2 + y**2) → sqrt(13) → 3.6
vec2(2.0, 3.0).length() // => 3.6055512

        // length が最低 3.7 以上になるように調整したベクトルを返す
vec2(2.0, 3.0).clamp_length_min(3.7) // => Vec2(2.0523908, 3.078586)

        // length が最大 4.0 以下になるように調整したベクトルを返す
vec2(2.0, 3.0).clamp_length_max(3.5) // => Vec2(1.9414507, 2.9121761)

        // clamp_length_min(3.5) と clamp_length_max(3.7) を一括指定
vec2(2.0, 3.0).clamp_length(3.5, 3.7) // => Vec2(2.0, 3.0)

        // x**2 + y**2 → 2**2 + 3**2 → 13.0
vec2(2.0, 3.0).length_squared() // => 13.0

        // 1.0 / length
vec2(2.0, 3.0).length_recip() // => 0.2773501

        // 引数を原点と考える。あとは上と同じ
vec2(10.0, 10.0).distance(vec2(12.0, 13.0))                // => 3.6055512
vec2(10.0, 10.0).distance_squared(vec2(12.0, 13.0))        // => 13.0

```

## 正規化
```rust
        // ダメなら Vec2(NaN, NaN)
vec2(2.0, 3.0).normalize()                             // => Vec2(0.5547002, 0.8320503)
vec2(0.0, 0.0).normalize()                             // => Vec2(NaN, NaN)

        // ダメなら None
vec2(2.0, 3.0).try_normalize()                         // => Some(Vec2(0.5547002, 0.8320503))
vec2(0.0, 0.0).try_normalize()                         // => None

        // ダメなら Vec2::ZERO
vec2(2.0, 3.0).normalize_or_zero()                     // => Vec2(0.5547002, 0.8320503)
vec2(0.0, 0.0).normalize_or_zero()                     // => Vec2(0.0, 0.0)

        // 正規化してある？
vec2(2.0, 3.0).is_normalized()                         // => false
vec2(2.0, 3.0).normalize().is_normalized()             // => true

        // recip は reciprocal の略だろうか？
        // 《略語》【文法】reciprocal（相互的な）
        // (1.0 / x, 1.0 / y)
vec2(2.0, 3.0).recip()                                 // => Vec2(0.5, 0.33333334)
```

## 線型補完
## 第二引数(s)が 0 なら self で 1 なら other になる
## self + (other - self) * s
```rust
vec2(0.0, 0.0).lerp(vec2(4.0, 4.0), -0.5) // => Vec2(-2.0, -2.0)
vec2(0.0, 0.0).lerp(vec2(4.0, 4.0), 0.0)  // => Vec2(0.0, 0.0)
vec2(0.0, 0.0).lerp(vec2(4.0, 4.0), 0.5)  // => Vec2(2.0, 2.0)
vec2(0.0, 0.0).lerp(vec2(4.0, 4.0), 1.0)  // => Vec2(4.0, 4.0)
vec2(0.0, 0.0).lerp(vec2(4.0, 4.0), 1.5)  // => Vec2(6.0, 6.0)
```

## 角度
```rust
        // 右下・真下・左下
vec2(2.0, 2.0).angle()   // => 0.7853982
vec2(0.0, 2.0).angle()   // => 1.5707963
vec2(-2.0, 2.0).angle()  // => 2.3561945

        // これと一致するので angle は全体を 2 * PI とした角度を返すことがわかる
PI * 0.25 // => 0.7853982
PI * 0.50 // => 1.5707964
PI * 0.75 // => 2.3561945

        // 2点間の角度差
        // other.angle - self.angle 相当
        // 右下.angle_between(真下) → PI * 0.25 → 0.7853982
vec2(2.0, 2.0).angle_between(vec2(0.0, 2.0))    // => 0.7853982
vec2(0.0, 2.0).angle() - vec2(2.0, 2.0).angle() // => 0.78539807

        // 右向き(2,0)を時計回りに90度回転すると真下(0,2)になる
vec2(2.0, 0.0).rotate(PI * 0.5).round() // => Vec2(-0.0, 2.0)
```

## 法線
## 法線(-y, x) 90度回転したものと同じ。長さもそのまま。
```rust
vec2(2.0, 3.0).perp()                                  // => Vec2(-3.0, 2.0)
vec2(2.0, 3.0).rotate(2.0 * PI * 90.0 / 360.0) // => Vec2(-3.0, 1.9999999)
```

## 内積・外積
```rust
        // 内積
        // x1 * x2 + y1 * y2
vec2(2.0, 3.0).dot(vec2(4.0, 5.0)) // => 23.0
2 * 4 + 3 * 5                      // => 23

        // 外積
        // x1 * y2 - x2 * y1
vec2(2.0, 3.0).perp_dot(vec2(4.0, 5.0)) // => -2.0
2 * 5 - 4 * 3                           // => -2

        #[allow(non_snake_case)]
        let A = vec2(3.0, 4.0);
        #[allow(non_snake_case)]
        let B = vec2(6.0, 2.0);

        // 投影
        // AをBに投影する
        // 言い替えるとAから垂直にBに線を降ろしたときの交点を返す
A.project_onto(B)                        // => Vec2(3.9, 1.3000001)
        // 投影先が正規化されいるときに使えるメソッドで結果は同じ
A.project_onto_normalized(B.normalize()) // => Vec2(3.8999999, 1.3)

        // 垂直方向への投影
        // 投影した点からAへのまで
        // (A - 投影)なので A - vec2(3.9, 1.3) となる
A.reject_from(B)                        // => Vec2(-0.9000001, 2.6999998)
A.reject_from_normalized(B.normalize()) // => Vec2(-0.89999986, 2.7)
A - A.project_onto(B)                   // => Vec2(-0.9000001, 2.6999998)
```

## 成分の入れ替え
```rust
vec2(1.0, 2.0).xy() // => Vec2(1.0, 2.0)
vec2(1.0, 2.0).yx() // => Vec2(2.0, 1.0)
vec2(1.0, 2.0).xx() // => Vec2(1.0, 1.0)
vec2(1.0, 2.0).yy() // => Vec2(2.0, 2.0)

vec2(1.0, 2.0).xxx() // => Vec3(1.0, 1.0, 1.0)
vec2(1.0, 2.0).xxy() // => Vec3(1.0, 1.0, 2.0)
vec2(1.0, 2.0).xyx() // => Vec3(1.0, 2.0, 1.0)
vec2(1.0, 2.0).xyy() // => Vec3(1.0, 2.0, 2.0)
vec2(1.0, 2.0).yxx() // => Vec3(2.0, 1.0, 1.0)
vec2(1.0, 2.0).yxy() // => Vec3(2.0, 1.0, 2.0)
vec2(1.0, 2.0).yyx() // => Vec3(2.0, 2.0, 1.0)
vec2(1.0, 2.0).yyy() // => Vec3(2.0, 2.0, 2.0)

vec2(1.0, 2.0).xxxx() // => Vec4(1.0, 1.0, 1.0, 1.0)
vec2(1.0, 2.0).xxxy() // => Vec4(1.0, 1.0, 1.0, 2.0)
vec2(1.0, 2.0).xxyx() // => Vec4(1.0, 1.0, 2.0, 1.0)
vec2(1.0, 2.0).xxyy() // => Vec4(1.0, 1.0, 2.0, 2.0)
vec2(1.0, 2.0).xyxx() // => Vec4(1.0, 2.0, 1.0, 1.0)
vec2(1.0, 2.0).xyxy() // => Vec4(1.0, 2.0, 1.0, 2.0)
vec2(1.0, 2.0).xyyx() // => Vec4(1.0, 2.0, 2.0, 1.0)
vec2(1.0, 2.0).xyyy() // => Vec4(1.0, 2.0, 2.0, 2.0)
vec2(1.0, 2.0).yxxx() // => Vec4(2.0, 1.0, 1.0, 1.0)
vec2(1.0, 2.0).yxxy() // => Vec4(2.0, 1.0, 1.0, 2.0)
vec2(1.0, 2.0).yxyx() // => Vec4(2.0, 1.0, 2.0, 1.0)
vec2(1.0, 2.0).yxyy() // => Vec4(2.0, 1.0, 2.0, 2.0)
vec2(1.0, 2.0).yyxx() // => Vec4(2.0, 2.0, 1.0, 1.0)
vec2(1.0, 2.0).yyxy() // => Vec4(2.0, 2.0, 1.0, 2.0)
vec2(1.0, 2.0).yyyx() // => Vec4(2.0, 2.0, 2.0, 1.0)
vec2(1.0, 2.0).yyyy() // => Vec4(2.0, 2.0, 2.0, 2.0)
```

## 定数
```rust
Vec2::ZERO      // => Vec2(0.0, 0.0)
Vec2::ONE       // => Vec2(1.0, 1.0)
Vec2::X         // => Vec2(1.0, 0.0)
Vec2::Y         // => Vec2(0.0, 1.0)
Vec2::AXES      // => [Vec2(1.0, 0.0), Vec2(0.0, 1.0)]
Vec2::default() // => Vec2(0.0, 0.0)
```

## 種類
```rust
vec2(2.0, 3.0)      // => Vec2(2.0, 3.0)
vec2(2.0, 3.0)      // => Vec2(2.0, 3.0)
ivec2(-2, -3)       // => IVec2(-2, -3)
uvec2(2, 3)         // => UVec2(2, 3)
dvec2(2.0, 3.0)     // => DVec2(2.0, 3.0)
```

## 3次元SIMD対応版
```rust
Vec3A::new(2.0, 3.0, 4.0)             // => Vec3A(2.0, 3.0, 4.0)
Vec3A::new(2.0, 3.0, 4.0).truncate()  // => Vec2(2.0, 3.0)
```

```rust
BVec2::new(true, false) // => BVec2(0xffffffff, 0x0)

BVec2::new(false, false).bitmask() // => 0
BVec2::new(true, false).bitmask()  // => 1
BVec2::new(false, true).bitmask()  // => 2
BVec2::new(true, true).bitmask()   // => 3

BVec2::new(true, false).any()   // => true
BVec2::new(true, true).all()   // => true

BVec2::new(true, true) & BVec2::new(true, false)   // => BVec2(0xffffffff, 0x0)
BVec2::new(true, false) | BVec2::new(false, true)   // => BVec2(0xffffffff, 0xffffffff)

!BVec2::new(true, false)   // => BVec2(0x0, 0xffffffff)
```

// これはなんだろう？
// vec2(2.0, 3.0).point2()    // => [2.0, 3.0]
