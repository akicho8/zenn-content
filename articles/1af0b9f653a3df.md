---
title: "動詞が先に来る英語はオブジェクト思考言語と相性が悪い？"
emoji: "🐤"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["命名規則"]
published: true
---

こんなコードがあってこの部分を1つにまとめたい。

```ruby
item.x += 1
item.y += 1
item.z += 1
```

一般的な命名規則は動詞が先なので item を update するメソッドは自然と update_item になる。

例えば次のように──

```ruby
def update_item(item)
  item.x += 1
  item.y += 1
  item.z += 1
end
```

このような命名規則にしている方は多いし、上の例ほどシンプルではないけどこんな感じの処理を書いているコードもよく見かける。

で、あるとき、よくよく見たらこれ item に対しての更新しかしてないし今後も何か増えそうなので item オブジェクト側で定義した update メソッドを呼んだ方がいいんじゃないかと考えるかもしれない。

そこでリファクタリングするとこうなる──

```ruby
def update_item(item)
  item.update
end
```

ここで違和感がある。
メソッド名が update → item なのに対して、実際の処理は item → update と逆の単語の並びになっている。
もし、最初から「アイテムを更新する」と日本語で発音するかのように item_update と命名していたらどうだろう？

```ruby
def item_update(item)
end
```

item_update と命名した時点でもう何かおかしいことに気づくんじゃなかろうか。
item.update でいいんちゃうんかと。
なんでこんなところに item_update なんて定義しようとしてたんかと。


似たような例として set_xxx というメソッドがあってリファクタリングしていくうち最終的に xxx.set になったりするケースが多いように感じる。これも最初から xxx_set というメソッド名にしていれば、その時点で xxx の set メソッドを呼ぶべきだったと矛盾に気づけたと思える。

したがって動詞が先に来る英語はオブジェクト思考言語と相性が悪い(小声)

## おまけ

Ruby には set で始まるメソッドなんかないのでわかりやすいと書こうとしたらけっこうあったわ。

```ruby
methods = ObjectSpace.each_object(Module).collect_concat(&:instance_methods).uniq
puts methods.grep(/^set/)
# >> set_backtrace
# >> setuid
# >> setgid
# >> setruid
# >> setrgid
# >> seteuid
# >> setegid
# >> setreuid
# >> setregid
# >> setresuid
# >> setresgid
# >> set_trace_func
# >> setpgrp
# >> setpgid
# >> setsid
# >> setpriority
# >> setrlimit
# >> setproctitle
# >> setuid?
# >> setgid?
# >> set_encoding
# >> setbyte
```

`_set` で終わるメソッドは──

```ruby
methods = ObjectSpace.each_object(Module).collect_concat(&:instance_methods).uniq
puts methods.grep(/_set$/)
# >> const_set
# >> class_variable_set
# >> instance_variable_set
# >> source_set
# >> thread_variable_set
# >> local_variable_set
```

いやもう統一して

