---
title: "Rust製テキスト検索ツール ripgrep (rg) の使い方メモ"
emoji: "🔎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ripgrep", "rg", "rust"]
published: false
---

たくさんある grep 系のツールのなかで [ripgrep](https://github.com/BurntSushi/ripgrep) はいちばん速いそうです。
速いといっても grep 系ツールはどれも十分に速いので速度にはあまり関心がないですが、Gitとの親和性がよく使いやすさの方が気にいっています。

# インストール #

```shell
cargo install ripgrep
```

  * 2022-07-18 での最新バージョンは 13.0.0

# オプション #

#### 表示の仕方 ####

| 表記                            | 意味                                                    |
|---------------------------------|---------------------------------------------------------|
| -C, --context <NUM>             | マッチした行の上下NUM行も表示                           |
| -A, --after-context <NUM>       | マッチした行の下NUM行も表示                             |
| -B, --before-context <NUM>      | マッチした行の上NUM行も表示                             |
| --context-separator <SEP>       | -A -B -C を使ったときの境目の '--' を変更できる         |
| --field-context-separator <SEP> | -A -B -C を使ったときのマッチしてない行の横の境目の変更 |

| 表記                          | 意味                                              |
|-------------------------------|---------------------------------------------------|
| -c, --count                   | マッチした**行数**を表示する                      |
| --count-matches               | マッチした**個数**を表示する                      |
| --include-zero                | マッチしないとき0を表示する                       |
| --with-filename               | 対象のファイルが1つのときでもファイル名を表示する |

| 表記                           | 意味                                                         |
|--------------------------------|--------------------------------------------------------------|
| --binary                       | バイナリファイルも見る                                       |
| -b, --byte-offset              |                                                              |
| -s, --case-sensitive           | 大文字小文字の違いを区別する                                 |
| --color <WHEN>                 | never なら全体で色を無効化                                   |
| --colors <COLOR_SPEC>...       | 'match:fg:cyan' ならマッチした部分が水色になる               |
| --column                       | カラム位置も表示する ファイル名:行:カラム                    |
| --only-matching                | マッチした行ではなく部分だけ表示する                         |
| --crlf                         | 改行コードが \r\n なときでも $ が行末にマッチするようにする  |
| --debug                        | どの設定ファイルで何が有効になったか調べるときに使う         |
| --trace                        | さらにどこで何がマッチしたかみたいなのもわかる(開発者用)     |
| --dfa-size-limit <NUM+SUFFIX?> | 正規表現 DFA の上限の制限                                    |
| -E, --encoding <ENCODING>      | shift_jis のときは -E shift_jis とする                       |
| --engine <ENGINE>              | 正規表現のライブラリを明示する。知らなくていい               |
| --field-match-separator <SEP>  | 「ファイル名:行」の「:」の部分の変更                         |
| -f, --file <PATTERNFILE>...    | 指定のファイルからパターンを読み込む                         |
| --files                        | 検索は行わず、対象のファイル名を列挙する                     |
| -l, --files-with-matches       | マッチしたファイル名を表示する                               |
| --files-without-match          | マッチしなかったファイル名を表示する                         |
| -F, --fixed-strings            | パターンを正規表現としない                                   |
| -L, --follow                   | symlink 先を追う                                             |
| -g, --glob <GLOB>...           | 対象を glob 形式で書く (.gitignore の書き方と同じ)           |
| --glob-case-insensitive        | --glob のとき大文字小文字の区別をしない                      |
| --iglob                        | --glob --glob-case-insensitive と同じ                        |
| --heading                      | ファイル名とマッチした行を一緒に表示しない(デフォルト・不便) |
| -., --hidden                   | "." で始まるファイルやディレクトリも見る                     |
| -i, --ignore-case              | 大文字小文字を区別しない                                     |
| --ignore-file <PATH>...        | .gitignore 形式の別のファイルを指定する                      |
| --ignore-file-case-insensitive | ?                                                            |
| -v, --invert-match             | マッチしなかった行を表示する                                 |
| --json                         | JSON 形式で表示                                              |
| --line-buffered                |                                                              |
| --block-buffered               | 表示するとき1行単位ではなくバッファ単位にする                |
| -n, --line-number              | 行番号を表示する (デフォルト)                                |

    -x, --line-regexp
            Only show matches surrounded by line boundaries. This is equivalent to putting
            ^...$ around all of the search patterns. In other words, this only prints lines
            where the entire line participates in a match.

            This overrides the --word-regexp flag.

    -M, --max-columns <NUM>
            Don't print lines longer than this limit in bytes. Longer lines are omitted,
            and only the number of matches in that line is printed.

            When this flag is omitted or is set to 0, then it has no effect.

        --max-columns-preview
            When the '--max-columns' flag is used, ripgrep will by default completely
            replace any line that is too long with a message indicating that a matching
            line was removed. When this flag is combined with '--max-columns', a preview
            of the line (corresponding to the limit size) is shown instead, where the part
            of the line exceeding the limit is not shown.

            If the '--max-columns' flag is not set, then this has no effect.

            This flag can be disabled with '--no-max-columns-preview'.

    -m, --max-count <NUM>
            Limit the number of matching lines per file searched to NUM.

        --max-depth <NUM>
            Limit the depth of directory traversal to NUM levels beyond the paths given. A
            value of zero only searches the explicitly given paths themselves.

            For example, 'rg --max-depth 0 dir/' is a no-op because dir/ will not be
            descended into. 'rg --max-depth 1 dir/' will search only the direct children of
            'dir'.

        --max-filesize <NUM+SUFFIX?>
            Ignore files larger than NUM in size. This does not apply to directories.

            The input format accepts suffixes of K, M or G which correspond to kilobytes,
            megabytes and gigabytes, respectively. If no suffix is provided the input is
            treated as bytes.

            Examples: --max-filesize 50K or --max-filesize 80M

        --mmap
            Search using memory maps when possible. This is enabled by default when ripgrep
            thinks it will be faster.

            Memory map searching doesn't currently support all options, so if an
            incompatible option (e.g., --context) is given with --mmap, then memory maps
            will not be used.

            Note that ripgrep may abort unexpectedly when --mmap if it searches a file that
            is simultaneously truncated.

            This flag overrides --no-mmap.

    -U, --multiline
            Enable matching across multiple lines.

            When multiline mode is enabled, ripgrep will lift the restriction that a match
            cannot include a line terminator. For example, when multiline mode is not
            enabled (the default), then the regex '\p{any}' will match any Unicode
            codepoint other than '\n'. Similarly, the regex '\n' is explicitly forbidden,
            and if you try to use it, ripgrep will return an error. However, when multiline
            mode is enabled, '\p{any}' will match any Unicode codepoint, including '\n',
            and regexes like '\n' are permitted.

            An important caveat is that multiline mode does not change the match semantics
            of '.'. Namely, in most regex matchers, a '.' will by default match any
            character other than '\n', and this is true in ripgrep as well. In order to
            make '.' match '\n', you must enable the "dot all" flag inside the regex.
            For example, both '(?s).' and '(?s:.)' have the same semantics, where '.' will
            match any character, including '\n'. Alternatively, the '--multiline-dotall'
            flag may be passed to make the "dot all" behavior the default. This flag only
            applies when multiline search is enabled.

            There is no limit on the number of the lines that a single match can span.

            **WARNING**: Because of how the underlying regex engine works, multiline
            searches may be slower than normal line-oriented searches, and they may also
            use more memory. In particular, when multiline mode is enabled, ripgrep
            requires that each file it searches is laid out contiguously in memory
            (either by reading it onto the heap or by memory-mapping it). Things that
            cannot be memory-mapped (such as stdin) will be consumed until EOF before
            searching can begin. In general, ripgrep will only do these things when
            necessary. Specifically, if the --multiline flag is provided but the regex
            does not contain patterns that would match '\n' characters, then ripgrep
            will automatically avoid reading each file into memory before searching it.
            Nevertheless, if you only care about matches spanning at most one line, then it
            is always better to disable multiline mode.

            This flag can be disabled with --no-multiline.

        --multiline-dotall
            This flag enables "dot all" in your regex pattern, which causes '.' to match
            newlines when multiline searching is enabled. This flag has no effect if
            multiline searching isn't enabled with the --multiline flag.

            Normally, a '.' will match any character except newlines. While this behavior
            typically isn't relevant for line-oriented matching (since matches can span at
            most one line), this can be useful when searching with the -U/--multiline flag.
            By default, the multiline mode runs without this flag.

            This flag is generally intended to be used in an alias or your ripgrep config
            file if you prefer "dot all" semantics by default. Note that regardless of
            whether this flag is used, "dot all" semantics can still be controlled via
            inline flags in the regex pattern itself, e.g., '(?s:.)' always enables "dot
            all" whereas '(?-s:.)' always disables "dot all".

            This flag can be disabled with --no-multiline-dotall.

        --no-config
            Never read configuration files. When this flag is present, ripgrep will not
            respect the RIPGREP_CONFIG_PATH environment variable.

            If ripgrep ever grows a feature to automatically read configuration files in
            pre-defined locations, then this flag will also disable that behavior as well.

    -I, --no-filename
            Never print the file path with the matched lines. This is the default when
            ripgrep is explicitly instructed to search one file or stdin.

            This flag overrides --with-filename.

        --no-heading
            Don't group matches by each file. If --no-heading is provided in addition to
            the -H/--with-filename flag, then file paths will be printed as a prefix for
            every matched line. This is the default mode when not printing to a terminal.

            This overrides the --heading flag.

        --no-ignore
            Don't respect ignore files (.gitignore, .ignore, etc.). This implies
            --no-ignore-dot, --no-ignore-exclude, --no-ignore-global, no-ignore-parent and
            --no-ignore-vcs.

            This does *not* imply --no-ignore-files, since --ignore-file is specified
            explicitly as a command line argument.

            When given only once, the -u flag is identical in behavior to --no-ignore and
            can be considered an alias. However, subsequent -u flags have additional
            effects; see --unrestricted.

            This flag can be disabled with the --ignore flag.

        --no-ignore-dot
            Don't respect .ignore files.

            This does *not* affect whether ripgrep will ignore files and directories
            whose names begin with a dot. For that, see the -./--hidden flag.

            This flag can be disabled with the --ignore-dot flag.

        --no-ignore-exclude
            Don't respect ignore files that are manually configured for the repository
            such as git's '.git/info/exclude'.

            This flag can be disabled with the --ignore-exclude flag.

        --no-ignore-files
            When set, any --ignore-file flags, even ones that come after this flag, are
            ignored.

            This flag can be disabled with the --ignore-files flag.

        --no-ignore-global
            Don't respect ignore files that come from "global" sources such as git's
            `core.excludesFile` configuration option (which defaults to
            `$HOME/.config/git/ignore`).

            This flag can be disabled with the --ignore-global flag.

        --no-ignore-messages
            Suppresses all error messages related to parsing ignore files such as .ignore
            or .gitignore.

            This flag can be disabled with the --ignore-messages flag.

        --no-ignore-parent
            Don't respect ignore files (.gitignore, .ignore, etc.) in parent directories.

            This flag can be disabled with the --ignore-parent flag.

        --no-ignore-vcs
            Don't respect version control ignore files (.gitignore, etc.). This implies
            --no-ignore-parent for VCS files. Note that .ignore files will continue to be
            respected.

            This flag can be disabled with the --ignore-vcs flag.

    -N, --no-line-number
            Suppress line numbers. This is enabled by default when not searching in a
            terminal.

        --no-messages
            Suppress all error messages related to opening and reading files. Error
            messages related to the syntax of the pattern given are still shown.

            This flag can be disabled with the --messages flag.

        --no-mmap
            Never use memory maps, even when they might be faster.

            This flag overrides --mmap.

        --no-pcre2-unicode
            DEPRECATED. Use --no-unicode instead.

            This flag is now an alias for --no-unicode. And --pcre2-unicode is an alias
            for --unicode.

        --no-require-git
            By default, ripgrep will only respect global gitignore rules, .gitignore rules
            and local exclude rules if ripgrep detects that you are searching inside a
            git repository. This flag allows you to relax this restriction such that
            ripgrep will respect all git related ignore rules regardless of whether you're
            searching in a git repository or not.

            This flag can be disabled with --require-git.

        --no-unicode
            By default, ripgrep will enable "Unicode mode" in all of its regexes. This
            has a number of consequences:

            * '.' will only match valid UTF-8 encoded scalar values.
            * Classes like '\w', '\s', '\d' are all Unicode aware and much bigger
              than their ASCII only versions.
            * Case insensitive matching will use Unicode case folding.
            * A large array of classes like '\p{Emoji}' are available.
            * Word boundaries ('\b' and '\B') use the Unicode definition of a word
              character.

            In some cases it can be desirable to turn these things off. The --no-unicode
            flag will do exactly that.

            For PCRE2 specifically, Unicode mode represents a critical trade off in the
            user experience of ripgrep. In particular, unlike the default regex engine,
            PCRE2 does not support the ability to search possibly invalid UTF-8 with
            Unicode features enabled. Instead, PCRE2 *requires* that everything it searches
            when Unicode mode is enabled is valid UTF-8. (Or valid UTF-16/UTF-32, but for
            the purposes of ripgrep, we only discuss UTF-8.) This means that if you have
            PCRE2's Unicode mode enabled and you attempt to search invalid UTF-8, then
            the search for that file will halt and print an error. For this reason, when
            PCRE2's Unicode mode is enabled, ripgrep will automatically "fix" invalid
            UTF-8 sequences by replacing them with the Unicode replacement codepoint. This
            penalty does not occur when using the default regex engine.

            If you would rather see the encoding errors surfaced by PCRE2 when Unicode mode
            is enabled, then pass the --no-encoding flag to disable all transcoding.

            The --no-unicode flag can be disabled with --unicode. Note that
            --no-pcre2-unicode and --pcre2-unicode are aliases for --no-unicode and
            --unicode, respectively.

    -0, --null
            Whenever a file path is printed, follow it with a NUL byte. This includes
            printing file paths before matches, and when printing a list of matching files
            such as with --count, --files-with-matches and --files. This option is useful
            for use with xargs.

        --null-data
            Enabling this option causes ripgrep to use NUL as a line terminator instead of
            the default of '\n'.

            This is useful when searching large binary files that would otherwise have very
            long lines if '\n' were used as the line terminator. In particular, ripgrep
            requires that, at a minimum, each line must fit into memory. Using NUL instead
            can be a useful stopgap to keep memory requirements low and avoid OOM (out of
            memory) conditions.

            This is also useful for processing NUL delimited data, such as that emitted
            when using ripgrep's -0/--null flag or find's --print0 flag.

            Using this flag implies -a/--text.

        --one-file-system
            When enabled, ripgrep will not cross file system boundaries relative to where
            the search started from.

            Note that this applies to each path argument given to ripgrep. For example, in
            the command 'rg --one-file-system /foo/bar /quux/baz', ripgrep will search both
            '/foo/bar' and '/quux/baz' even if they are on different file systems, but will
            not cross a file system boundary when traversing each path's directory tree.

            This is similar to find's '-xdev' or '-mount' flag.

            This flag can be disabled with --no-one-file-system.

    -o, --only-matching
            Print only the matched (non-empty) parts of a matching line, with each such
            part on a separate output line.

        --passthru
            Print both matching and non-matching lines.

            Another way to achieve a similar effect is by modifying your pattern to match
            the empty string. For example, if you are searching using 'rg foo' then using
            'rg "^|foo"' instead will emit every line in every file searched, but only
            occurrences of 'foo' will be highlighted. This flag enables the same behavior
            without needing to modify the pattern.

            This overrides the --context, --after-context and --before-context flags.

        --path-separator <SEP>
            Set the path separator to use when printing file paths. This defaults to your
            platform's path separator, which is / on Unix and \ on Windows. This flag is
            intended for overriding the default when the environment demands it (e.g.,
            cygwin). A path separator is limited to a single byte.

    -P, --pcre2
            When this flag is present, ripgrep will use the PCRE2 regex engine instead of
            its default regex engine.

            This is generally useful when you want to use features such as look-around
            or backreferences.

            Note that PCRE2 is an optional ripgrep feature. If PCRE2 wasn't included in
            your build of ripgrep, then using this flag will result in ripgrep printing
            an error message and exiting. PCRE2 may also have worse user experience in
            some cases, since it has fewer introspection APIs than ripgrep's default regex
            engine. For example, if you use a '\n' in a PCRE2 regex without the
            '-U/--multiline' flag, then ripgrep will silently fail to match anything
            instead of reporting an error immediately (like it does with the default
            regex engine).

            Related flags: --no-pcre2-unicode

            This flag can be disabled with --no-pcre2.

        --pcre2-version
            When this flag is present, ripgrep will print the version of PCRE2 in use,
            along with other information, and then exit. If PCRE2 is not available, then
            ripgrep will print an error message and exit with an error code.

        --pre <COMMAND>
            For each input FILE, search the standard output of COMMAND FILE rather than the
            contents of FILE. This option expects the COMMAND program to either be an
            absolute path or to be available in your PATH. Either an empty string COMMAND
            or the '--no-pre' flag will disable this behavior.

                WARNING: When this flag is set, ripgrep will unconditionally spawn a
                process for every file that is searched. Therefore, this can incur an
                unnecessarily large performance penalty if you don't otherwise need the
                flexibility offered by this flag. One possible mitigation to this is to use
                the '--pre-glob' flag to limit which files a preprocessor is run with.

            A preprocessor is not run when ripgrep is searching stdin.

            When searching over sets of files that may require one of several decoders
            as preprocessors, COMMAND should be a wrapper program or script which first
            classifies FILE based on magic numbers/content or based on the FILE name and
            then dispatches to an appropriate preprocessor. Each COMMAND also has its
            standard input connected to FILE for convenience.

            For example, a shell script for COMMAND might look like:

                case "$1" in
                *.pdf)
                    exec pdftotext "$1" -
                    ;;
                *)
                    case $(file "$1") in
                    *Zstandard*)
                        exec pzstd -cdq
                        ;;
                    *)
                        exec cat
                        ;;
                    esac
                    ;;
                esac

            The above script uses `pdftotext` to convert a PDF file to plain text. For
            all other files, the script uses the `file` utility to sniff the type of the
            file based on its contents. If it is a compressed file in the Zstandard format,
            then `pzstd` is used to decompress the contents to stdout.

            This overrides the -z/--search-zip flag.

        --pre-glob <GLOB>...
            This flag works in conjunction with the --pre flag. Namely, when one or more
            --pre-glob flags are given, then only files that match the given set of globs
            will be handed to the command specified by the --pre flag. Any non-matching
            files will be searched without using the preprocessor command.

            This flag is useful when searching many files with the --pre flag. Namely,
            it permits the ability to avoid process overhead for files that don't need
            preprocessing. For example, given the following shell script, 'pre-pdftotext':

                #!/bin/sh

                pdftotext "$1" -

            then it is possible to use '--pre pre-pdftotext --pre-glob '*.pdf'' to make
            it so ripgrep only executes the 'pre-pdftotext' command on files with a '.pdf'
            extension.

            Multiple --pre-glob flags may be used. Globbing rules match .gitignore globs.
            Precede a glob with a ! to exclude it.

            This flag has no effect if the --pre flag is not used.

    -p, --pretty
            This is a convenience alias for '--color always --heading --line-number'. This
            flag is useful when you still want pretty output even if you're piping ripgrep
            to another program or file. For example: 'rg -p foo | less -R'.

    -q, --quiet
            Do not print anything to stdout. If a match is found in a file, then ripgrep
            will stop searching. This is useful when ripgrep is used only for its exit
            code (which will be an error if no matches are found).

            When --files is used, then ripgrep will stop finding files after finding the
            first file that matches all ignore rules.

        --regex-size-limit <NUM+SUFFIX?>
            The upper size limit of the compiled regex. The default limit is 10M.

            The argument accepts the same size suffixes as allowed in the --max-filesize
            flag.

    -e, --regexp <PATTERN>...
            A pattern to search for. This option can be provided multiple times, where
            all patterns given are searched. Lines matching at least one of the provided
            patterns are printed. This flag can also be used when searching for patterns
            that start with a dash.

            For example, to search for the literal '-foo', you can use this flag:

                rg -e -foo

            You can also use the special '--' delimiter to indicate that no more flags
            will be provided. Namely, the following is equivalent to the above:

                rg -- -foo

    -r, --replace <REPLACEMENT_TEXT>
            Replace every match with the text given when printing results. Neither this
            flag nor any other ripgrep flag will modify your files.

            Capture group indices (e.g., $5) and names (e.g., $foo) are supported in the
            replacement string. Capture group indices are numbered based on the position of
            the opening parenthesis of the group, where the leftmost such group is $1. The
            special $0 group corresponds to the entire match.

            In shells such as Bash and zsh, you should wrap the pattern in single quotes
            instead of double quotes. Otherwise, capture group indices will be replaced by
            expanded shell variables which will most likely be empty.

            To write a literal '$', use '$$'.

            Note that the replacement by default replaces each match, and NOT the entire
            line. To replace the entire line, you should match the entire line.

            This flag can be used with the -o/--only-matching flag.

    -z, --search-zip
            Search in compressed files. Currently gzip, bzip2, xz, LZ4, LZMA, Brotli and
            Zstd files are supported. This option expects the decompression binaries to be
            available in your PATH.

            This flag can be disabled with --no-search-zip.

    -S, --smart-case
            Searches case insensitively if the pattern is all lowercase. Search case
            sensitively otherwise.

            A pattern is considered all lowercase if both of the following rules hold:

            First, the pattern contains at least one literal character. For example, 'a\w'
            contains a literal ('a') but just '\w' does not.

            Second, of the literals in the pattern, none of them are considered to be
            uppercase according to Unicode. For example, 'foo\pL' has no uppercase
            literals but 'Foo\pL' does.

            This overrides the -s/--case-sensitive and -i/--ignore-case flags.

        --sort <SORTBY>
            This flag enables sorting of results in ascending order. The possible values
            for this flag are:

                none      (Default) Do not sort results. Fastest. Can be multi-threaded.
                path      Sort by file path. Always single-threaded.
                modified  Sort by the last modified time on a file. Always single-threaded.
                accessed  Sort by the last accessed time on a file. Always single-threaded.
                created   Sort by the creation time on a file. Always single-threaded.

            If the chosen (manually or by-default) sorting criteria isn't available on your
            system (for example, creation time is not available on ext4 file systems), then
            ripgrep will attempt to detect this, print an error and exit without searching.

            To sort results in reverse or descending order, use the --sortr flag. Also,
            this flag overrides --sortr.

            Note that sorting results currently always forces ripgrep to abandon
            parallelism and run in a single thread.

        --sortr <SORTBY>
            This flag enables sorting of results in descending order. The possible values
            for this flag are:

                none      (Default) Do not sort results. Fastest. Can be multi-threaded.
                path      Sort by file path. Always single-threaded.
                modified  Sort by the last modified time on a file. Always single-threaded.
                accessed  Sort by the last accessed time on a file. Always single-threaded.
                created   Sort by the creation time on a file. Always single-threaded.

            If the chosen (manually or by-default) sorting criteria isn't available on your
            system (for example, creation time is not available on ext4 file systems), then
            ripgrep will attempt to detect this, print an error and exit without searching.

            To sort results in ascending order, use the --sort flag. Also, this flag
            overrides --sort.

            Note that sorting results currently always forces ripgrep to abandon
            parallelism and run in a single thread.

        --stats
            Print aggregate statistics about this ripgrep search. When this flag is
            present, ripgrep will print the following stats to stdout at the end of the
            search: number of matched lines, number of files with matches, number of files
            searched, and the time taken for the entire search to complete.

            This set of aggregate statistics may expand over time.

            Note that this flag has no effect if --files, --files-with-matches or
            --files-without-match is passed.

            This flag can be disabled with --no-stats.

    -a, --text
            Search binary files as if they were text. When this flag is present, ripgrep's
            binary file detection is disabled. This means that when a binary file is
            searched, its contents may be printed if there is a match. This may cause
            escape codes to be printed that alter the behavior of your terminal.

            When binary file detection is enabled it is imperfect. In general, it uses
            a simple heuristic. If a NUL byte is seen during search, then the file is
            considered binary and search stops (unless this flag is present).
            Alternatively, if the '--binary' flag is used, then ripgrep will only quit
            when it sees a NUL byte after it sees a match (or searches the entire file).

            This flag can be disabled with '--no-text'. It overrides the '--binary' flag.

    -j, --threads <NUM>
            The approximate number of threads to use. A value of 0 (which is the default)
            causes ripgrep to choose the thread count using heuristics.

        --trim
            When set, all ASCII whitespace at the beginning of each line printed will be
            trimmed.

            This flag can be disabled with --no-trim.

    -t, --type <TYPE>...
            Only search files matching TYPE. Multiple type flags may be provided. Use the
            --type-list flag to list all available types.

            This flag supports the special value 'all', which will behave as if --type
            was provided for every file type supported by ripgrep (including any custom
            file types). The end result is that '--type all' causes ripgrep to search in
            "whitelist" mode, where it will only search files it recognizes via its type
            definitions.

        --type-add <TYPE_SPEC>...
            Add a new glob for a particular file type. Only one glob can be added at a
            time. Multiple --type-add flags can be provided. Unless --type-clear is used,
            globs are added to any existing globs defined inside of ripgrep.

            Note that this MUST be passed to every invocation of ripgrep. Type settings are
            NOT persisted. See CONFIGURATION FILES for a workaround.

            Example:

                rg --type-add 'foo:*.foo' -tfoo PATTERN.

            --type-add can also be used to include rules from other types with the special
            include directive. The include directive permits specifying one or more other
            type names (separated by a comma) that have been defined and its rules will
            automatically be imported into the type specified. For example, to create a
            type called src that matches C++, Python and Markdown files, one can use:

                --type-add 'src:include:cpp,py,md'

            Additional glob rules can still be added to the src type by using the
            --type-add flag again:

                --type-add 'src:include:cpp,py,md' --type-add 'src:*.foo'

            Note that type names must consist only of Unicode letters or numbers.
            Punctuation characters are not allowed.

        --type-clear <TYPE>...
            Clear the file type globs previously defined for TYPE. This only clears the
            default type definitions that are found inside of ripgrep.

            Note that this MUST be passed to every invocation of ripgrep. Type settings are
            NOT persisted. See CONFIGURATION FILES for a workaround.

        --type-list
            Show all supported file types and their corresponding globs.

    -T, --type-not <TYPE>...
            Do not search files matching TYPE. Multiple type-not flags may be provided. Use
            the --type-list flag to list all available types.

    -u, --unrestricted
            Reduce the level of "smart" searching. A single -u won't respect .gitignore
            (etc.) files (--no-ignore). Two -u flags will additionally search hidden files
            and directories (-./--hidden). Three -u flags will additionally search binary
            files (--binary).

            'rg -uuu' is roughly equivalent to 'grep -r'.

    -V, --version
            Prints version information

        --vimgrep
            Show results with every match on its own line, including line numbers and
            column numbers. With this option, a line with more than one match will be
            printed more than once.

    -H, --with-filename
            Display the file path for matches. This is the default when more than one
            file is searched. If --heading is enabled (the default when printing to a
            terminal), the file path will be shown above clusters of matches from each
            file; otherwise, the file name will be shown as a prefix for each matched line.

            This flag overrides --no-filename.

    -w, --word-regexp
            Only show matches surrounded by word boundaries. This is roughly equivalent to
            putting \b before and after all of the search patterns.

            This overrides the --line-regexp flag.

#

# はまりがちなこと #

#### --no-ignore-parent が効かない？ ####

# 実用例 #

#### 拡張子が png の怪しいファイルのヘッダに PNG が含まれるか確認する ####

```shell
rg --binary PNG image.png
```

  * --binary でバイナリファイルも見る
  * file コマンドでいい気がした

#### 改行コードだと \r\n だと $ が改行にマッチしない問題 ####

```shell
$ ruby -e '"foo\r\n".display' > a.txt
$ rg 'foo$' a.txt
$ rg 'foo$' a.txt --crlf
1:foo
```

#### Windows で作られたファイルが読めない ####

```shell
rg -E shift_jis あ a.txt
```


