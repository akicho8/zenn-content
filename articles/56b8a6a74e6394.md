---
title: "テキスト検索ツール ripgrep (rg) の使い方メモ"
emoji: "🔎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["ripgrep", "rg", "rust"]
published: false
---

https://github.com/BurntSushi/ripgrep

# インストール #

```shell
cargo install ripgrep
```

  * 2022-07-18 での最新バージョンは 13.0.0

##### 更新方法 #####

```shell
cargo install cargo-update
cargo install-update --list
cargo install-update --all
```

# オプション #

#### 検索パターンの解釈 ####

| 表記                 | 意味                                                   |
|----------------------|--------------------------------------------------------|
| -i, --ignore-case    | 大文字小文字を区別しない。 /foo/i                      |
| -s, --case-sensitive | 大文字小文字を区別する。 /foo/                         |
| -w, --word-regexp    | 単語とみなす。 /\bfoo\b/                               |
| -S, --smart-case     | 大文字が含まれるときだけ。 /Foo/i ではなく /Foo/       |
| -x, --line-regexp    | 1行分マッチさせる。 foo が /^foo$/ になる              |
| -U, --multiline      | 複数行に跨って検索できる。 a\nb には a\nb でマッチ |
| --multiline-dotall   | -U と合わせて指定すると a\nb に a.b でマッチする   |
| -F, --fixed-strings  | 正規表現としない                                       |

#### 結果表示の方法 ####

| 表記                     | 意味                                                    |
|--------------------------|---------------------------------------------------------|
| --no-heading             | ファイル名をマッチした行と一緒に表示する(必須)          |
| -l, --files-with-matches | マッチしたファイル名だけ列挙する                        |
| -m, --max-count <N>      | ファイルごとに一致する行数を N に制限する               |
| -n, --line-number        | 行番号を表示する (デフォルト)                           |
| -H, --with-filename      | 1つのファイルを指定しているときでもファイル名を表示する |
| --trim                   | 表示の際に左側のスペースを取る。Ruby の lstrip 相当     |
| -q, --quiet              | 何も表示しない                                          |

#### 結果表示の方法 (めったに使わない) ####

| 表記                          | 意味                                                       |
|-------------------------------|------------------------------------------------------------|
| --files-without-match         | マッチしなかったファイル名だけ列挙する                     |
| -v, --invert-match            | マッチしなかった行を表示する                               |
| -I, --no-filename             | ファイル名を表示しない                                     |
| --heading                     | ファイル名を一緒に表示しない (デフォルトかつ不便)          |
| --column                      | カラム位置も表示する ファイル名:行:**カラム**              |
| -N, --no-line-number          | 行番号を表示しない                                         |
| -p, --pretty                  | --color always --heading --line-number の一括指定。less 用 |
| --vimgrep                     | 1行でN回マッチしたらカラム位置情報と合わせてN行分表示する  |
| --path-separator <SEP>        | 表示する際のパスの '/' を変更できる                        |
| --field-match-separator <SEP> | 「ファイル名:行」の「:」の部分の変更                       |

#### マッチした数を表示する ####

| 表記            | 意味                                              |
|-----------------|---------------------------------------------------|
| -c, --count     | マッチした行数を表示する                          |
| --count-matches | マッチした個数を表示する                          |
| --include-zero  | マッチしないときでも0を表示する                   |

#### 長すぎる一行を途中で切る ####

| 表記                  | 意味                               |
|-----------------------|------------------------------------|
| -M, --max-columns <N> | N 文字以上なら一行まるごと省略する |
| --max-columns-preview | N 文字分は表示する                 |

  * --max-columns だけだと一行がまるごと省略メッセージに置き換わってしまう
  * --max-columns-preview も指定すると「途中で切る」になる
  * `*.min.js` にマッチして大変な目に合わないよう初期値にしておく

#### WIP:バイナリファイルの扱い ####

#### 対象のファイルをGLOB形式で書く ####

| 表記                    | 意味                                      |
|-------------------------|-------------------------------------------|
| -g, --glob <GLOB>...    | 対象をGLOB形式で書く                      |
| --glob-case-insensitive | --glob のとき、大文字小文字の区別をしない |
| --iglob                 | --glob --glob-case-insensitive と同じ     |

`rg foo *.rb` と書いてもGLOB形式だけど、これはカレントディレクトリだけの `*.rb` を対象として、シェルが展開してしまうので -g とはかなり動作が異なる

#### 対象を広げる ####

| 表記             | 意味                   |
|------------------|------------------------|
| -L, --follow     | symlink 先を追う       |
| -z, --search-zip | 圧縮ファイルの中も見る |

#### ファイル容量やディレクトリの深さで制限する ####

| 表記                       | 意味                                      |
|----------------------------|-------------------------------------------|
| --max-filesize <N+SUFFIX?> | 100K なら 100KB 以下のファイルだけ見る    |
| --max-depth <N>            | ディレクトリの深さNまで。自分=1 子=2 孫=3 |
| --one-file-system          | ファイルシステムを跨がない                |

#### さらに除外する ####

| 表記                           | 意味                                     |
|--------------------------------|------------------------------------------|
| --ignore-file <PATH>...        | .gitignore 形式の別のファイルを指定する  |
| --ignore-file-case-insensitive | ?                                        |

#### 除外条件を緩くする ####

| 表記                 | 意味                                               |
|----------------------|----------------------------------------------------|
| -u, --unrestricted   | -u -uu -uuu と増やす度に制限が緩くなる             |
| --no-ignore          | なんとか ignore や exclude を全部を無視する        |
| -., --hidden         | "." で始まるファイルやディレクトリも見る           |
| --no-ignore-dot      | .ignore を無視する                                 |
| --no-ignore-exclude  | .git/info/exclude を無視する                       |
| --no-ignore-files    | --ignore-file の指定を無視する                     |
| --no-ignore-global   | $HOME/.config/git/ignore の指定を無視する          |
| --no-ignore-parent   | 先祖ディレクトリにある ignore 系ファイルを無視する |
| --no-ignore-vcs      | Git管理下の除外設定を無視する                      |
| --no-ignore-messages | ?                                                  |

#### ファイルのグループ化 ####

| 表記                      | 意味                                         |
|---------------------------|----------------------------------------------|
| --type-list               | 事前にグループ化されているキーを確認する     |
| -t, --type <TYPE>...      | -t ruby なら Ruby に関連するファイルを探す   |
| -T, --type-not <TYPE>...  | -T ruby なら Ruby に関連しないファイルを探す |
| --type-add <TYPE_SPEC>... | 登録 'ruby*.rb,Rakefile'                     |
| --type-clear <TYPE>...    | 削除                                         |

  * コマンドラインで使うのは基本 `-t` だけ
  * 初期設定ファイルであらかじめ登録しておく

#### バイナリファイルも見る ####

| 表記       | 意味                                                             |
|------------|------------------------------------------------------------------|
| --binary   | バイナリファイルも見る。中身の表示は控える                       |
| -a, --text | すべてをテキストと見なしてバイナリの中身もかまわず端末に出力する |

  * どちらを指定してもバイナリファイルを見る
  * --text の使うと端末がめちゃくちゃになるのでこっちは忘れていい

#### 文字コードがらみ ####

| 表記                      | 意味                                                        |
|---------------------------|-------------------------------------------------------------|
| -E, --encoding <ENCODING> | Shift_JIS のときは -E shift_jis とする                |
| --crlf                    | 改行が `\r\n` なときでも `$` が行末にマッチするようになる |

本来 `$` で `\r\n` にマッチするはずの正規表現エンジンが対応していないので、仕方なく ripgrep 側で `--crlf` オプションを用意しているらしい

結局 Windows なファイルには `-E shift_jis --crlf` としないといけない

#### 事前に別のコマンドを噛ます ####

| 表記                 | 意味                                                      |
|----------------------|-----------------------------------------------------------|
| --pre <COMMAND>      | 事前に COMMAND を噛ます。PDFやExcelをテキスト化するなど。 |
| --pre-glob <GLOB>... | --pre で指定のコマンドに送るファイルを絞る '*.pdf' など   |

#### 上下余分に表示する ####

| 表記                            | 意味                                      |
|---------------------------------|-------------------------------------------|
| -B, --before-context <N>        | マッチした行の上 N 行も表示する           |
| -A, --after-context <N>         | マッチした行の下 N 行も表示する           |
| -C, --context <N>               | マッチした行の上下 N 行も表示する         |
| --context-separator <SEP>       | 塊と塊の間の -- を変更する                |
| --field-context-separator <SEP> | 余分に表示した行の横の境目の - を変更する |

#### ファイル名の並び替え ####

| 表記             | 意味 |
|------------------|------|
| --sort <SORTBY>  | 正順 |
| --sortr <SORTBY> | 逆順 |

`none path modified accessed created` が指定できる

#### 検証用 ####

| 表記    | 意味                                                               |
|---------|--------------------------------------------------------------------|
| --files | 対象のファイルをすべて列挙する。そもそもファイル見てんのか？な時用 |
| --debug | どの設定ファイルで何が有効になったか調べるときに使う               |
| --trace | どこで何がマッチしたかみたいなのもわかる(開発者用)                 |

#### 統計表示 ####

| 表記    | 意味                                           |
|---------|------------------------------------------------|
| --stats | 何件中何個マッチしたかなどの情報を追加表示する |
| --json  | JSON 形式で表示                                |

  * --stats の情報をプログラムで読み取るなら --json をつけた方がいい
  * --json は --stats 専用ってわけじゃない

#### ブロック毎に出力するか？ 一行毎に出力するか？ ####

| 表記             | 意味                                |
|------------------|-------------------------------------|
| --block-buffered | ブロック毎に出力する (デフォルト)    |
| --line-buffered  | 一行毎に出力する                        |

単に端末に表示するなら `--block-buffered` の方が速いけど `tailf -f production.log | rg foo | foo bar` のような行指向でパイプ処理する場合、ブロック毎だと一行が途中で分断されてしまうかもしれないので `tailf -f production.log | rg --line-buffered foo | foo bar` とすればいいらしい。が、ブロック毎であっても行の分断を観測できなかったので本当に必要かはよくわかっていない。とりあえず行指向なパイプ処理のときは安全のために `--line-buffered` をつけておいた方がよさそう、ぐらいの認識。

#### 色 ####

| 表記                     | 意味                                           |
|--------------------------|------------------------------------------------|
| --color <WHEN>           | never なら OFF                                 |
| --colors <COLOR_SPEC>... | 'match:fg:cyan' ならマッチした部分が水色になる |

#### 正規表現関連 ####

| 表記                         | 意味                           |
|------------------------------|--------------------------------|
| --engine <ENGINE>            | 正規表現のライブラリを明示する |
| -P, --pcre2                  | PCRE2 に切り替える             |
| --pcre2-version              | ?                              |
| --dfa-size-limit <N+SUFFIX?> | 正規表現 DFA の上限の制限      |

  * ビルドの時点で PCRE2 を含めてないと切り替えられなかったので検証できなかった
  * PCRE は Perl で使われている正規表現ライブラリらしい

#### 知らなくてよさそうなやつ ####

| 表記                      | 意味                                         |
|---------------------------|----------------------------------------------|
| --mmap                    | 脆いが指定すると速くなるらしい (デフォルト)  |
| --no-mmap                 | 高速化の余地があってもメモリマップを使わない |
| -j, --threads <N>         | スレッド数の指定                             |
| --no-unicode              | 指定すると日本語が使えなくなる               |
| --regex-size-limit <N+S?> | コンパイルされた正規表現のサイズ制限         |

#### いまいち用途がわからないやつ ####

| 表記                 | 意味                                                    |
|----------------------|---------------------------------------------------------|
| --null-data          | マッチしたファイル全体を表示し、最後に NUL を入れる     |
| -r, --replace <TEXT> | マッチ箇所を置換 (ファイルを更新してくれるわけじゃない) |
| --passthru           | マッチしてない部分も全部表示する                        |

#### その他 ####

| 表記                 | 意味                                                         |
|----------------------|--------------------------------------------------------------|
| --no-config          | RIPGREP_CONFIG_PATH の先を読まない                           |
| -o, --only-matching  | マッチした行ではなくマッチした箇所だけ表示する               |
| -b, --byte-offset    | -o のときマッチした箇所の byte オフセットも表示              |
| -e, --regexp <P>...  | ハイフンで始まるパターン用。 `-- -foo` を `-e -foo` と書ける |
| -f, --file <FILE>... | 指定のファイルからパターンを読み込む                         |
| --no-messages        | ファイルの読み取り時のエラーを表示しない                     |
| -0, --null           | ファイル名の後で NUL を入れる。xargs -0 用                   |
| --no-require-git     | ?                                                            |

# はまりがちなこと #

#### ~/.ripgreprc を置いたのに読まれない ####

```ruby:~/.zshenv
export RIPGREP_CONFIG_PATH=$HOME/.ripgreprc
```

ホーム以下にドットファイルをぶちまけるのが良い規約だとは思っていないのかデフォルトでは置いても読まれない。ファイル名も決まってない。単に `RIPGREP_CONFIG_PATH` が指す先のファイルを読む。

#### Windows で作られたファイルが読めない ####

```shell
rg -E shift_jis あ a.txt
```

Shift_JIS のファイルを読むには `-E shift_jis` とする

#### Windows で作られたファイルの改行に $ がマッチしない ####

```shell
rg -E shift_jis 'あ$' --crlf a.txt
```

  * 正規表現ライブラリの不備で `\r\n` に `$` がマッチしない
  * `--crlf` を指定すると ripgrep 側でなんとかしてくれる

#### --type-add するときの include とは？ ####

```ruby
rg --type-add web:include:html,css -t web foo
```

既存の html と css のグループをまとめたってこと

```ruby
$ rg --type-list | rg -N '^(html|css):'
html: *.ejs, *.htm, *.html
css: *.css, *.scss
```

となるので、こう書くのと結果的には同じ

```ruby
rg --type-add 'web:*.{ejs,htm,html,css,scss}' -t web foo
```

#### ときどきファイル名が表示されない理由 ####

  * ファイルを1件指定したときはファイル名を表示しないようになっているから
  * 自明だから表示する必要がないだろうというわけ
  * ただ、これは指定するファイル数が変動する場合に困る
  * 1件でも2件でも同じように読み取りたいプログラムがあったとき1件だとバグる
  * 常にファイル名を表示するには `--with-filename` とする

#### --binary オプションが常に効いている？ ####

  * --binary はバイナリーファイルも読むオプション
  * なので `rg --binary PNG` とすると png ファイルにマッチする
    * ヘッダ内のPNG文字列がマッチする
  * ところが `--binary` を指定せず `rg PNG foo.png` としてもマッチする
  * これは探したファイルと明示的に指定されたファイルとでは扱いが異なるため
  * 明示的に指定されたファイルはデフォルトの除外ルールが省かれる
  * なので --binary の有無に関係なく foo.png は対象になる
  * このように従来の不親切なツールに慣れていると、親切な仕様に戸惑うことがある

#### --text オプションを指定したのにバイナリーファイルも見ている ####

  * 勘違いしやすいけど --text はテキストだけを見るオプションではない
  * 正しくはすべてをテキストとして扱うやばいオプション
  * なのでバイナリーファイルもテキストファイルとして扱う

# 実用例 #

#### *.min.js にマッチしてしまい端末が大変なことになったときの応手 ####

| Command           | 意味                           |
|-------------------|--------------------------------|
| -g '!*.min.js'    | *.min.js は除外する            |
| -T minified       | *.min.js っぽいやつは除外する  |
| --max-columns 100 | 表示する一行の文字数を制限する |

  * `--max-columns` を指定するときは `--max-columns-preview` も一緒に指定する
  * すると100文字目までは表示される

#### マッチしすぎるときの応手 ####

| Command              | 意味                                       |
|----------------------|--------------------------------------------|
| rg foo -t ruby       | 種類で絞る                                 |
| rg foo -g '*.rb'     | 拡張子で絞る                               |
| rg foo -g '\*user\*' | user が含まれるファイル名に絞る            |
| rg foo -g '!*.js'    | 絞るんじゃなくていらない方を除外する       |
| rg foo -m 3          | 1つのファイルにつき表示は3行だけにする     |
| rg foo -c            | ファイルとマッチした行数だけにする         |
| rg foo -l            | もうファイル名だけでいい                   |
| rg foo --max-depth 2 | ファイル名も多いので孫ディレクトリはみない |
| rg foo -q            | 何も表示しない                             |

#### 拡張子が png なのにヘッダに PNG が含まれない偽画像ファイルを探す ####

```shell
rg --files-without-match --binary -g '*.png' PNG
```

  * --binary オプションをつけると画像ファイルも読む

#### 検索結果をWEBで表示したい ####

```shell
rg --stats --json foo
```

  * --stats で検索に要した時間なども含める
  * --json でJSON化

活用すればただのテキストファイル郡が高速なデータベースとしても使えるかもしれない

#### さくっと結果を less する ####

```ruby
rg -p foo | less -R
```

  * -p オプションで less に特化した見やすい表示になる
  * less の -R は色を反映するオプション

#### バイナリファイルをテキスト化してから検索する ####

ちょっと面倒だけど、あらかじめPDFからテキストに変換するコマンドを用意しておく

```shell:~/bin/rg-preprocessor
#!/bin/sh
exec pdftotext - -
```

として `~/bin/rg-preprocessor something.pdf` でテキストが表示されればOK
次にコマンドを `--pre` に指定する

```shell
rg --pre ~/bin/rg-preprocessor foo
```

ただこれだとすべてのファイルが pdftotext に渡ってめちゃくちゃになるのでプリプロセッサーに渡るファイルを `*.pdf` に絞る

```shell
rg --pre ~/bin/rg-preprocessor --pre-glob '*.pdf' foo
```

このあたり、わりとややこしいので本家の説明を読む

https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#preprocessor
