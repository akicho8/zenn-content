---
title: "Capybaraでブラウザ操作自動化の知見まとめ"
emoji: "🦫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Capybara", "Ruby", "自動化"]
published: true
---

Capybara でブラウザ操作を自動化する際の泥臭い知見をまとめた。

## グローバルに chromedriver がある

```shell
$ which chromedriver
/usr/local/var/rbenv/shims/chromedriver
```

- それは chromedriver-helper gem の残骸
- 他にも chromedriver で始まる外部コマンドがあるはず
- gem も含めて抹殺する

```shell
$ gem uni -ax chromedriver-helper
$ rm /usr/local/var/rbenv/shims/chromedriver*
```

## また chromedriver が出てきた

```shell
$ which chromedriver
/usr/local/bin/chromedriver
```

- それは `brew install chromedriver` で入れたやつ
- 抹殺する

```shell
$ brew uninstall chromedriver
```

## chromedriver がない

```
Failure/Error: raise Error::WebDriverError, self.class.missing_text unless path

Selenium::WebDriver::Error::WebDriverError:
  Unable to find chromedriver. Please download the server from
  https://chromedriver.storage.googleapis.com/index.html and place it somewhere on your PATH.
  More info at https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver.
```

- エラーメッセージ通りに「ここからダウンロードして PATH を設定」してはいけない
- webdrivers gem を使う

## chromedriver はローカルのどこにある？

```shell
$ exa -al --no-user ~/.webdrivers
.rwxr-xr-x 17M 10 7  2021 chromedriver
.rw-r--r--  13 16 5 06:23 chromedriver.version
```

## chromedriver があるのに動作しない

- Google Chrome と chromedriver のバージョンが一致していない
- コマンドラインですぐにバージョンを確認できるようにしておく

```shell:~/bin/capybara-version-check
"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --version
~/.webdrivers/chromedriver --version
```

- Google Chrome が 70 以上であれば chromedriver とのバージョンは一致すると webdrivers の README に書いてある
- しかし Google Chrome が自動アップデートされた直後に同じバージョンの chromedriver が用意されてないことがあった
- それで一回事故って大変な目にあったので時差があるのではないかと疑っている
- ただ昔のことで記憶が怪しいけど、もしかしたら brew の chromedriver と chromedriver-helper と webdrivers がそれぞれ何をするものか正確に把握できておらず webdrivers gem を正しく使えてなかったのかもしれない。もしそうなら webdrivers にはすまん

## バージョンが一致しない事故を防ぐ

### 方法1. Google Chrome を自動更新させない

これなら絶対にずれない。
まず更新チェック頻度を 0 にする。

```shell
defaults write com.google.Keystone.Agent checkInterval 0
```

次にアップデート関連のプログラムを抹殺＆ダミーに置き換える。
~/Library 側

```shell
sudo rm -R ~/Library/Google/GoogleSoftwareUpdate/
sudo touch ~/Library/Google/GoogleSoftwareUpdate
sudo chmod 444 ~/Library/Google/GoogleSoftwareUpdate
sudo rm ~/Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R ~/Library/Caches/com.google.Keystone*
sudo rm ~/Library/Preferences/com.google.Keystone.Agent.plist
```

/Library 側

```shell
sudo rm -R /Library/Google/GoogleSoftwareUpdate/
sudo touch /Library/Google/GoogleSoftwareUpdate
sudo chmod 444 /Library/Google/GoogleSoftwareUpdate
sudo rm /Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R /Library/Caches/com.google.Keystone*
sudo rm /Library/Preferences/com.google.Keystone.Agent.plist
```

上の手順はかなり昔の作業メモからひっぱってきたものなので現在その通りにして期待通りになるかはわからない (じゃぁ載せんな。危ないし)

### 方法2. いざ事故ったら手動で戻す

そのために日々バックアップを取っておく。

```sh:~/bin/capybara-env-backup.sh
#!/bin/sh
# (cd /Applications && rm -fr .git)
# (cd ~/.webdrivers && rm -fr .git)
# exit

cd /Applications
[ ! -d .git ] && git init -q
git add -A "Google Chrome.app"
"./Google Chrome.app/Contents/MacOS/Google Chrome" --version | git commit -uno -F -

cd ~/.webdrivers
[ ! -d .git ] && git init -q
git add -A
./chromedriver --version | git commit -F -
```

これを cron にセットしておく。

webdrivers は Google Chrome のバージョンに合わせた chromedriver を用意してくれるはずなので ~/.webdrivers をバックアップする必要はないのかもしれない。が、まさにその部分が信用できていないので、こちらも管理下に入れてすぐ戻せるようにしておく。

それと、いざというときに `/Applications/Google Chrome.app` だけを過去に戻して Google Chrome 自体が起動するのか不安ではあるが、それは運を天に任せる。とりあえず常時アップデートしていきたい場合はこっちの方がよい。

### 方法3. ハイブリッド方式

結局こうした

1. 自動更新を止める
1. バックアップも取る
1. その上で、月に1回ほど手動で Google Chrome をアップデートする
    - 具体的には普通に新規でダウンロードして /Applications にコピる
    - すぐに webdrivers を読み込んで同じバージョンの chromedriver が入ったか確認する

## Selenium で警告が出る

```
WARN Selenium [DEPRECATION] [:browser_options] :options as a parameter for driver initialization is deprecated. Use :capabilities with an Array of value capabilities/options if necessary instead.
```

- capybara が古いのが原因
- どこで直ったのかはわからないけど 3.37.1 以上だと警告は出なくなっていた
  - ただ 3.37.1 にするには Ruby 2.7.0 以上を求められる

## rack application が必要だと言われる

```shell
rack-test requires a rack application, but none was given (ArgumentError)
```

見なかったことにして current_driver に :selenium_chrome を指定する。

```ruby
Capybara.current_driver = :selenium_chrome
```

## `require "capybara/dsl"` するとどうなる？

- 一つのブラウザしか使わないとした上でいろいろ短かく書ける
- Capybara.page で Capybara.current_session を呼べる
- Capybara.page に対するメソッドが Capybara モジュール自体に生える
- つまり Capybara.xxx は Capybara.current_session.xxx を呼ぶ

## Capybara.xxx と書くのが面倒

グローバルにぶちまけると怒られるので

```ruby
module Playground
  extend Capybara::DSL

  visit("https://www.google.co.jp/")
end
```

または

```ruby
class App
  include Capybara::DSL

  def run
    visit "https://www.google.co.jp/"
  end

  new.run
end
```

Capybara の名前が長いのが気になる場合

```ruby
module C
  extend Capybara::DSL
end

C.visit "https://www.google.co.jp/"
```

いや、それなら `C = Capybara` でいい気がする

## 途中で止めてDOMの構造を調べる

- byebug gem を入れる
- 本当は debug gem の方がいいのかもしれない
  - が、 eshell からなぜか動かないので byebug にする
  - 具体的には debug gem が使っている irb が動かない
- さくさく調べたいので default_max_wait_time を 0 にしてから debugger を起動する

```ruby
Capybara.using_wait_time(0) { debugger }
```

- snippet 的なやつですぐに入力できるようにしておく

## ローカルの HTML ファイルが読めない

- コマンドラインから `open foo.html` で開けるので `Capybara.visit("foo.html")` で開いてくれても良さそうだけど開けない
  - invalid argument と言われるだけ
- `file://` からのフルパスにすると読める

```ruby
file = Pathname("foo.html").expand_path
Capybara.visit("file://#{file}")
```

## 待つ

- assert_xxx 系のメソッドはその状態になるまで待つのに使える
- sleep を使ったら負けだと思え

## 待ち秒数を変更する

指定したメソッドだけ
```ruby
Capybara.assert_title("Google", wait: 1)
```

局所的
```ruby
Capybara.using_wait_time(1) do
  Capybara.default_max_wait_time # => 1
end
```

全体
```ruby
Capybara.default_max_wait_time = 2
```

- マッチしないときにとりあえず値を大きくすればいいんじゃね？ としてしまいがちだけど、これで解決することはほぼない
- 逆に失敗の判定をしていた部分で時間がかかるようになるので増やすな
- デフォルト 2 のままで良い。触んな
- 指定するとしたら wait オプションだけに留める

## 指定の要素が1件になるまで待つ

インクリメンタル検索で結果の数が変動する場合に有用

```ruby
Capybara.assert_selector(".foo", count: 1)
```

## 指定のパスになるまで待つ

```ruby
Capybara.visit("https://www.youtube.com/results?search_query=capybara")
Capybara.assert_current_path("/results?search_query=capybara")
Capybara.assert_current_path("/results", ignore_query: true)
```

## サイトが 200 を返すまで待つ

```ruby
require "faraday"

url = "https://www.google.co.jp/"
loop do
  response = Faraday.get(url)
  p [Time.now.strftime("%F %T"), response.reason_phrase]
  if response.success?
    break
  end
  sleep(2)
end
```

Capybara だと戻値がわからないので節操なく faraday を使う

## WEBにアクセスせずにセレクタの練習をする

```ruby
node = Capybara.string("<a></a>")
node.has_selector?("a") # => true
```

## default_selector が :css なのに xpath も書けるのはなぜ？

```ruby
Capybara.default_selector # => :css
node = Capybara.string("<a></a>")
node.has_selector?("a")   # => true
node.has_selector?("//a") # => true
```

Nokogiri が融通を効かせて `LOOKS_LIKE_XPATH` にマッチすると xpath と見なしているっぽい

```ruby
Nokogiri::XML::Searchable::LOOKS_LIKE_XPATH # => /^(\.\/|\/|\.\.|\.$)/
node = Nokogiri.XML("<a></a>")
node.at("a")              # => #<Nokogiri::XML::Element:0x9ec name="a">
node.at("//a")            # => #<Nokogiri::XML::Element:0x9ec name="a">
```

つまり `/` で始まっているから xpath と見なす (続く)

## `/` で始まっていたら xpath と見なすのでは？

```ruby
node = Capybara.string("<a>xxx</a>")
node.has_selector?("//a[text()='xxx']")                    # => true
node.has_selector?("//a[contains(text(), 'x')]") rescue $! # => #<Nokogiri::CSS::SyntaxError: unexpected 'text(' after 'contains('>
```

- `text()='xxx'` は問題ないが `contains(text(), 'x')` で失敗する
- `CSS::SyntaxError` とあるので CSS として見ている？
- 試しに `:xpath` を明示すると通った

```ruby
node.has_selector?(:xpath, "//a[contains(text(), 'x')]")   # => true
```

Nokogiri 側では問題ないので Capybara でも似たようなことをやろうとしてうまくいっていないのかもしれない

```ruby
node = Nokogiri.XML("<a>xxx</a>")
node.at("//a[text()='xxx']")          # => #<Nokogiri::XML::Element:0xa00 name="a" children=[#<Nokogiri::XML::Text:0x9ec "xxx">]>
node.at("//a[contains(text(), 'x')]") # => #<Nokogiri::XML::Element:0xa00 name="a" children=[#<Nokogiri::XML::Text:0x9ec "xxx">]>
```

結論
- xpath を書くときは :xpath を明示した方が確実
- `assert_selector?("//...")` → `assert_selector?(:xpath, "//...")`
- `assert_selector?("//...")` → `assert_xpath?("//...")`
- `has_selector?("//...")` → `has_xpath?("//...")`
- `find("//...")` → `find(:xpath, "//...")`

## ラベルに正確にマッチさせる

```ruby
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer name:", with: "foo", exact: true)
```

- exact は **正確** の意味
- 毎回 `exact: true` と書く状況なら `Capybara.exact = true` としておく

## グローバルで `exact = true` にすると assert_text も完全一致モードになる？

- ならない
- assert_text には専用の `Capybara.exact_text` がある
- が、これをグローバルで設定することは普通ない
- メソッドに指定するときは `assert_text "xxx", exact: true` と書く
  - `exact_text: true` ではない点に注意

## 改行やスペースの影響で assert_text の判定が揺らぐ

```ruby
Capybara.assert_text("foo bar", normalize_ws: true)
```

- `normalize_ws: true` すると対象を `gsub(/[[:space:]]+/, ' ').strip` する
- なので `foo \n bar` にも `foo bar` がマッチするようになる

## assert_text でマッチしない

- 想定する画面になっていないのがほとんどの原因
- デバッガで止めて以下を確認
  - `Capybara.title`
  - `Capybara.current_url`
  - `Capybara.page.text`
  - `Capybara.page.text.include?("xxx")`

## マウス操作では押せるのにプログラムから押せない

1. サイト側の仕組みで処理中の操作を禁止するため画面を div で覆っている
1. 処理が終わって画面を覆うエフェクトは消えた
1. だが、画面を覆う div が完全には取り除かれていない

そんなときに不整合が起きるようだ。
マウスではクリックできるが、Capybara からはクリックできないという。

```
*** Selenium::WebDriver::Error::ElementClickInterceptedError Exception:
element click intercepted: Element <button>...</button> is not clickable at point (1503, 193).
Other element would receive the click: <div class="foo"></div>
```

エラー内容は .foo が邪魔して button が押せなかったという意味なので邪魔する要素を抹殺する。

```ruby
Capybara.execute_script("document.querySelector('.foo').remove()")
```

## 確実に選択できるセレクターを得る

- Developer Tool で該当タグを `Copy Selector` でコピる
- あとのことは知らない、今動けばいい──場合に有用

## `Copy Selector` でコピったのに選択できない

- iframe が使われているのが原因
- within_frame(selector) で iframe 内に入る

```html
<body>
  <iframe>
    <form></form>
  </iframe>
</body>
```

```ruby
Capybara.has_selector?("form")     # => false
Capybara.within_frame("iframe") do
  Capybara.assert_selector("form") # => true
end
```

## セレクタのリファクタリング

```html:対象
<button><span>送信する</span></button>
```

タグの構造を含めて完全一致でマッチする

```ruby
has_xpath?("//button/span[text()='送信する']")
```

テキストは部分一致で良い

```ruby
has_xpath?("//button/span[contains(text(), '送信')]")
```

span が別のタグになるかもしれない

```ruby
has_xpath?("//button/*[contains(text(), '送信')]")
```

span が無くなるかもしれない

```ruby
has_xpath?("//button[contains(., '送信')]")
```

contains と書きたくない

```ruby
has_xpath?("//button", text: "送信")
```

`//` を書きたくない

```ruby
has_css?("button", text: "送信")
```

button タグとは限らない

```ruby
has_selector?(:link_or_button, text: "送信")
```

それをクリックしたい

```ruby
find(:link_or_button, text: "送信").click
```

短かく書きたい

```ruby
click_on("送信")
```

## 文言だけを頼りにそれを直下に持つタグを探す

```ruby
find(:xpath, "//*[contains(text(), '送信')]") # => #<Capybara::Node::Simple tag="span" path="/html/body/button/span">
find(:xpath, "//*[text()='送信する']")        # => #<Capybara::Node::Simple tag="span" path="/html/body/button/span">
```

- `text()` は自分の直下のテキストなのでマッチすれば自分自身のタグが返る
- 昨今のフロントエンドは何が click できるのか想像つかない
- とりあえず、その文言を持ったタグを click すれば伝搬するだろう
- そういうとき用

## セレクタに `*` や `.` を使ったときのはまりどころ

トップレベルの HTML タグにマッチしている

```ruby
find(:xpath, "*", text: "送信") # => #<Capybara::Node::Simple tag="html" path="/html">
```

html, body, button, span のすべてのタグがマッチしている

```ruby
find(:xpath, "//*", text: "送信")        rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*" with text "送信">
find(:element, text: "送信")             rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible element nil with text "送信">
find(:xpath, "//*[.='送信する']")        rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*[.='送信する']">
find(:xpath, "//*[contains(., '送信')]") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*[contains(., '送信')]">
```

## 「送信」を選択するつもりが「送信確認」にもマッチしてしまう

```ruby
node = Capybara.string("<button>送信確認</button><button>送信</button>")
node.find("button", text: "送信") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 2 elements matching visible css "button" with text "送信">
```

- `exact_text: true` をつけると完全一致になる
  - `exact` なのか `exact_text` なのかややこしい
- `text` オプションを正規表現にする方法もある

```ruby
node.find("button", text: "送信", exact_text: true).path # => "/html/body/button[2]"
node.find("button", text: /\A送信\z/).path               # => "/html/body/button[2]"
```

- xpath であれば contains を避ける

```ruby
node.find(:xpath, "//*[contains(text(), '送信')]") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 2 elements matching visible xpath "//*[contains(text(), '送信')]">
node.find(:xpath, "//*[text()='送信']").path # => "/html/body/button[2]"
```

## HTMLを自分で用意して検証する

実際のサイトの深部に行くのが難しい場合はローカルに再現したHTMLで検証する。

```ruby
require "tempfile"

SOURCE = <<~EOT
  <a href="https://www.google.co.jp/">検索</a>
EOT

path = Tempfile.open(["", ".html"]) { |e| e.tap { |e| e << SOURCE } }.path
Capybara.visit("file://#{path}")

Capybara.click_on("検索")
gets
```

- 実際のサイトで動作検証を重ねていると迷惑がかかるためなるべくローカルで行う
- 探索中の HTML を保存するには `Capybara.save_page("foo.html")` とする
- 単にセレクタの確認であれば `Capybara.string` を使う
- こちらはクリックイベントなど、ブラウザの挙動を含めて確認したいときに有用

## `target="_blank"` で開いたタブに移動する

```ruby
Capybara.switch_to_window(Capybara.windows.last)
```

## 新しいタブを開いて移動して何かして閉じて戻る

```ruby
Capybara.within_window(Capybara.open_new_window) do
  # Capybara.visit("https://www.youtube.com/")
  # 何かする
  Capybara.current_window.close
end
```

## タブを閉じる

今いるタブを閉じる

```ruby
if Capybara.current_window != Capybara.windows.first
  Capybara.current_window.close
end
```

他のタブをすべて閉じる

```ruby
(Capybara.windows.drop(1) - [Capybara.current_window]).each(&:close)
```

右側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows.drop(windows.find_index(current_window).next).each(&:close)
end
```

左側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows[1...windows.find_index(current_window)].each(&:close)
end
```

すべてのタブを閉じる

```ruby
Capybara.reset!
```

- いちばん左端のタブ `windows.first` は close できない
- close しようとすると `Not allowed to close the primary window`

## JavaScript を実行して結果を取得する

```ruby
p Capybara.evaluate_script("window.navigator.userAgent")
# >> "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
```

## D&Dでファイルアップロードする

dropybara gem を追加する

```ruby
`convert logo: file.png`
Capybara.visit("https://css-tricks.com/examples/DragAndDropFileUploading/")
Capybara.page.drop_file("form", "file.png")
```

## テキストフィールドに set したつもりが追記されてしまう

```ruby
Capybara.find(".foo").set("xxx", clear: :backspace)
```

## マウスを乗せないとドロップダウンメニューが開かない

```ruby
Capybara.find(".foo").hover
```

## `command + a` で、すべてを選択

```ruby
Capybara.find("html").send_keys([:command, "a"])
```

## ページの最後まで移動する

```ruby
Capybara.find("html").send_keys(:end)
```

## クリップボードにコピーしてくる

```ruby
module Clipboard
  extend self

  def write(text)
    IO.popen("pbcopy", "w") { |io| io.write(text) }
  end

  def read
    IO.popen("pbpaste", &:read)
  end
end

Clipboard.write("")
Capybara.visit("https://www.ruby-lang.org/ja/")
Capybara.find("html").send_keys([:command, "a"])
Capybara.find("html").send_keys([:command, "c"])
puts Clipboard.read.lines.take(2)
# >> Ruby
# >> A PROGRAMMER'S BEST FRIEND
```

## JavaScript を使ってクリップボードに入れる

```ruby
Clipboard.write("")
Capybara.visit("https://www.google.co.jp/")
Capybara.execute_script("await navigator.clipboard.writeText('foo')")
Clipboard.read # => "foo"
Capybara.first("form input").send_keys([:command, "v"])
```

## XML ファイルは読めない

- Capybara は HTML を読む前提になっている
- Google Chrome は良かれと XML を HTML として装飾表示する
- 結果、Capybara が混乱する

```ruby
Capybara.visit("https://www.google.co.jp/sitemap.xml")
Capybara.page.text             rescue $! # => #<Capybara::ElementNotFound: Unable to find xpath "/html">
Capybara.assert_text("google") rescue $! # => #<Capybara::ElementNotFound: Unable to find xpath "/html">
Capybara.page.body[...40]                # => "<html xmlns=\"http://www.w3.org/1999/xhtm"
```

となるので faraday を使う

```ruby
response = Faraday.get("https://www.google.co.jp/sitemap.xml")
node = Nokogiri::XML(response.body)
node.search("sitemap").count # => 24
```

## YouTubeで画面サイズを調整してスクショを取る

```ruby
Capybara.visit("https://www.youtube.com/watch?v=Ftm2uv7-Ybw")
Capybara.current_window.resize_to(640, 480)
sleep(1)
Capybara.save_screenshot("youtube.png")
```

- YouTubeは画面のリサイズに応じてレイアウトが切り替わる
- が、かなりもっさりゆったりと切り替わる
- なので、このあたりは深追いせず見当つけて sleep を入れる (前言撤回)

## RSpec 実行時にスクショを集める

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
  gem "rspec", require: "rspec/autorun"
end

Capybara.current_driver = :selenium_chrome_headless

RSpec.configure do |config|
  config.before(:example) do |ex|
    @full_description = ex.full_description
  end

  config.include Module.new {
    def image_save
      name = @full_description.gsub(/\s+/, "_")
      Capybara.save_screenshot("#{name}.png")
    end
  }
end

RSpec.describe "Browsing" do
  it "Google" do
    Capybara.visit("https://www.google.co.jp/")
    image_save
  end

  it "YouTube" do
    Capybara.visit("https://www.youtube.com/")
    image_save
  end
end
# >> ..
# >>
# >> Finished in 7.38 seconds (files took 0.11407 seconds to load)
# >> 2 examples, 0 failures
# >>
```

```shell
$ exa -al --no-user Browsing*.png
.rw-r--r-- 130k 18 5 12:24 Browsing_Google.png
.rw-r--r-- 621k 18 5 12:24 Browsing_YouTube.png
```

- save_screenshot を呼んで保存したファイルからはどこのスクショだったか判断できない
- かといって、いちいちファイル名を指定したくない
- ので full_description を元にファイル名を決める
- スクショが欲しいところに image_save を置く

## 自動化処理中に状況を知らせる

これを定義しといて

```ruby
def say(message)
  system "say '#{message}'"
end
```

知らせたいところに置いとく

```ruby
say "ログイン完了"
```

## 自動化の敵 reCAPTCHA が出たら人間に頼む

これを定義しといて

```ruby
def pause(message = "一時停止")
  say message
  puts message
  gets
end
```

人間の助けが必要なところに挟む

```ruby
pause "reCAPTCHA を倒せ"
```

## visit メソッドを使いやすくする

GET パラメータとしてハッシュを渡せるようにする

```ruby
require "active_support/core_ext/object/to_query"
require "active_support/core_ext/object/blank"

Capybara::Session.prepend Module.new {
  def visit(uri, params = {})
    super [uri, params.to_query.presence].compact.join("?")
  end
}

Capybara.visit("https://www.google.co.jp/search", q: "foo")
```

## 使い捨てサンプル

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
end

Capybara.current_driver = :selenium_chrome

Capybara.visit "https://www.google.co.jp/"
Capybara.first("form input").set("foo")
Capybara.first("form input[type=submit]").click

gets
```
