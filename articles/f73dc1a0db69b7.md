---
title: "Capybaraでブラウザ操作自動化の知見まとめ"
emoji: "🦫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Capybara", "Ruby", "自動化"]
published: true
---

Capybara でブラウザ操作を自動化する際の泥臭い知見をまとめた。

## グローバルに chromedriver がある

```shell
$ which chromedriver
/usr/local/var/rbenv/shims/chromedriver
```

- それは chromedriver-helper gem の残骸
- 他にも chromedriver で始まる外部コマンドがあるはず
- gem も含めて抹殺する

```shell
$ gem uni -ax chromedriver-helper
$ rm /usr/local/var/rbenv/shims/chromedriver*
```

## また chromedriver が出てきた

```shell
$ which chromedriver
/usr/local/bin/chromedriver
```

- それは `brew install chromedriver` で入れたやつ
- 抹殺する

```shell
$ brew uninstall chromedriver
```

## chromedriver がない

```
Failure/Error: raise Error::WebDriverError, self.class.missing_text unless path

Selenium::WebDriver::Error::WebDriverError:
  Unable to find chromedriver. Please download the server from
  https://chromedriver.storage.googleapis.com/index.html and place it somewhere on your PATH.
  More info at https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver.
```

- エラーメッセージ通りに「ここからダウンロードして PATH を設定」してはいけない
- webdrivers gem を使う

## chromedriver はローカルのどこにある？

```shell
$ exa -al --no-user ~/.webdrivers
.rwxr-xr-x 17M 10 7  2021 chromedriver
.rw-r--r--  13 16 5 06:23 chromedriver.version
```

## chromedriver があるのに動作しない

- Google Chrome と chromedriver のバージョンが一致していない
- コマンドラインですぐにバージョンを確認できるようにしておく

```shell:~/bin/capybara-version-check
"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --version
~/.webdrivers/chromedriver --version
```

- Google Chrome が 70 以上であれば chromedriver とのバージョンは一致すると webdrivers の README に書いてある
- しかし Google Chrome が自動アップデートされた直後に同じバージョンの chromedriver が用意されてないことがあった
- それで一回事故って大変な目にあったので時差があるのではないかと疑っている
- ただ昔のことで記憶が怪しい。もしかしたら brew の chromedriver と chromedriver-helper と webdrivers がそれぞれ何をするものか正確に把握できておらず webdrivers を正しく使えてなかったのかもしれない。もしそうなら webdrivers にはすまん

## バージョンが一致しない事故を防ぐ

### 方法1. Google Chrome を自動更新させない

これなら絶対にずれない。
まず更新チェック頻度を 0 にする。

```shell
defaults write com.google.Keystone.Agent checkInterval 0
```

さにアップデート関連のプログラムを抹殺＆ダミーに置き換える。
~/Library 側

```shell
sudo rm -R ~/Library/Google/GoogleSoftwareUpdate/
sudo touch ~/Library/Google/GoogleSoftwareUpdate
sudo chmod 444 ~/Library/Google/GoogleSoftwareUpdate
sudo rm ~/Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R ~/Library/Caches/com.google.Keystone*
sudo rm ~/Library/Preferences/com.google.Keystone.Agent.plist
```

/Library 側

```shell
sudo rm -R /Library/Google/GoogleSoftwareUpdate/
sudo touch /Library/Google/GoogleSoftwareUpdate
sudo chmod 444 /Library/Google/GoogleSoftwareUpdate
sudo rm /Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R /Library/Caches/com.google.Keystone*
sudo rm /Library/Preferences/com.google.Keystone.Agent.plist
```

上の手順はかなり昔の作業メモからひっぱってきたものなので現在その通りにして期待通りになるかはわからない (じゃぁ載せんな。危ないし)

### 方法2. いざ事故ったら手動で戻す

そのために日々バックアップを取っておく。

```sh:~/bin/capybara-env-backup.sh
#!/bin/sh
# (cd /Applications && rm -fr .git)
# (cd ~/.webdrivers && rm -fr .git)
# exit

cd /Applications
[ ! -d .git ] && git init -q
git add -A "Google Chrome.app"
"./Google Chrome.app/Contents/MacOS/Google Chrome" --version | git commit -uno -F -

cd ~/.webdrivers
[ ! -d .git ] && git init -q
git add -A
./chromedriver --version | git commit -F -
```

これを cron にセットしておく。

webdrivers は Google Chrome のバージョンに合わせた chromedriver を用意してくれるはずなので ~/.webdrivers をバックアップする必要はないのかもしれない。が、まさにその部分が信用できていないので、こちらも管理下に入れてすぐ戻せるようにしておく。

それと、いざというときに `/Applications/Google Chrome.app` だけを過去に戻して Google Chrome 自体が起動するのか不安ではあるが、それは運を天に任せる。とりあえず常時アップデートしていきたい場合はこっちの方がよい。

### 方法3. ハイブリッド方式

結局こうした

1. 自動更新を止める
1. バックアップも取る
1. その上で、月に1回ほど手動で Google Chrome をアップデートする
    - 具体的には普通に新規でダウンロードして /Applications にコピる
    - すぐに webdrivers を読み込んで同じバージョンの chromedriver が入ったか確認する

## Selenium で警告が出る

```
WARN Selenium [DEPRECATION] [:browser_options] :options as a parameter for driver initialization is deprecated. Use :capabilities with an Array of value capabilities/options if necessary instead.
```

- capybara が古いのが原因
- どこで直ったのかはわからないが 3.37.1 以上だと警告は出なくなっていた
  - ただ 3.37.1 にするには Ruby 2.7.0 以上を求められる

## rack application が必要だと言われる

```shell
rack-test requires a rack application, but none was given (ArgumentError)
```

見なかったことにして current_driver に :selenium_chrome を指定する。

```ruby
Capybara.current_driver = :selenium_chrome
```

## `require "capybara/dsl"` するとどうなる？

- 一つのブラウザしか使わないとした上でいろいろ短かく書ける
- Capybara.page で Capybara.current_session を呼べる
- Capybara.page に対するメソッドが Capybara モジュール自体に生える
- つまり Capybara.xxx は Capybara.current_session.xxx を呼ぶ
- ショートカットできるメソッドは `Capybara::Session::DSL_METHODS` に列挙されているメソッドだけ
  - active_element などは current_session を経由で呼ぶこと

## Capybara.xxx と書くのが面倒

グローバルにぶちまけると怒られるので

```ruby
module Playground
  extend Capybara::DSL

  visit "https://www.google.co.jp/"
end
```

または

```ruby
class App
  include Capybara::DSL

  def run
    visit "https://www.google.co.jp/"
  end

  new.run
end
```

とする

Capybara の名前が長いのが気になる場合は

```ruby
module C
  extend Capybara::DSL
end

C.visit "https://www.google.co.jp/"
```

としても良いが、それなら `C = Capybara` でいい気がする

## 途中で止めてDOMの構造を調べる

- byebug gem を入れる
- 本当は debug gem の方がいいのかもしれない
  - が、 eshell から動かないので byebug にする
  - 具体的には debug gem が使っている irb が動かない
  - いくら調べてもわからない
- さくさく動作させたいので default_max_wait_time を 0 にしてから debugger を起動する

```ruby
Capybara.using_wait_time(0) { debugger }
```

- snippet 的なやつですぐに入力できるようにしておく

## ローカルの HTML ファイルが読めない

- コマンドラインからは `open foo.html` で開ける
- だから `Capybara.visit("foo.html")` で開いてくれても良さそうだけど開けない
- invalid argument と言われるだけ
- `file://` からのフルパスにすると読める

```ruby
file = Pathname("foo.html").expand_path
Capybara.visit("file://#{file}")
```

## XML が読めない

- Capybara は HTML が来る前提になっている
- Google Chrome は良かれと XML を HTML として装飾表示する
- 結果、Capybara が混乱する

```ruby
Capybara.visit("https://www.google.co.jp/sitemap.xml")
Capybara.page.text             rescue $! # => #<Capybara::ElementNotFound: Unable to find xpath "/html">
Capybara.assert_text("google") rescue $! # => #<Capybara::ElementNotFound: Unable to find xpath "/html">
Capybara.page.body[...40]                # => "<html xmlns=\"http://www.w3.org/1999/xhtm"
```

となるので faraday を使う

```ruby
require "faraday"
response = Faraday.get("https://www.google.co.jp/sitemap.xml")
node = Nokogiri::XML(response.body)
node.search("sitemap").count # => 24
```

## 待つ

assert_xxx 系メソッドと wait オプションを組み合わせると検証よりも**その状態になるまで待つ**のに使える

## 送信ボタンが表われるまで最大1分待つ

```ruby
Capybara.assert_selector("button", text: "送信", exact_text: true, wait: 60)
```

`sleep(5)` などとウェイトを入れてはいけない

## 指定のパスになるまで待つ

```ruby
Capybara.visit("https://www.youtube.com/results?search_query=capybara")
Capybara.assert_current_path("/results?search_query=capybara")
Capybara.assert_current_path("/results", ignore_query: true)
```

## assert_current_path では不十分なときがある

下手に AJAX を多用したサイトでは読み込みが終わったあとでも、まだローディングを続けていたりして、そのサイトに来てはいるが、コンテンツがまだ用意されていない場合がある。

そういうときはパスではなくコンテンツに含まれるものが表われるまで待つようにする。

```ruby:×ログインページには来ているが中身が空の場合がある
Capybara.assert_current_path("/login", wait: 60)
```

```ruby:○ログインボタンがあるということは全部読み込まれている
Capybara.assert_selector("button", text: "ログイン", exact_text: true, wait: 60)
```

## ありえないほど重いサイトにリロードを重ねて開くまで待つ例

```ruby
Capybara.visit("...")

success = false
100.times do |i|
  puts [i.next, Time.current, Capybara.current_url].join(" ")
  if Capybara.has_selector?("button", text: "送信", exact_text: true, wait: 60)
    success = true
    break
  end
  say "リロード#{i.next}回目"
  Capybara.visit(Capybara.current_url)
end
if !success
  say "失敗"
end
```

- `<button>送信</button>` があれば開いたと見なす
- 60秒経っても反応が無ければ死んでいるので再びリクエスト(リロード)する
- こんなことしないといけないサイトがあるのかと思うかもしれないが実際にある

## 待っているとPCのファンが唸りを上げてしまう原因と対策

こう書くと内部では 0.01 のウェイトが入っているため処理回数は1秒間で約100回、全体で約6000回になる

```ruby
Capybara.has_selector?(..., wait: 60)
```

こう置き換えると1秒に1回なので全体で60回になる

```ruby
60.times do
  break if Capybara.has_selector?(..., wait: 0)
  sleep(1)
end
```

タイムアウトしたきの判定も含めるとこうなる

```ruby
success = false
second = 1 # 1秒間毎に一瞬確認する
(60 / second).times do
  if Capybara.has_selector?(..., wait: 0)
    success = true
    break
  end
  sleep(second)
end
if success
  # 成功
else
  # 失敗
end
```

## 待ち秒数の指定は wait オプションだけに留める

待ち秒数を変更する方法はいくつかあるが──

指定したメソッドだけ
```ruby
Capybara.assert_title("Google", wait: 60)
```

局所的(忘れてよい)
```ruby
Capybara.using_wait_time(60) do
  Capybara.default_max_wait_time # => 60
end
```

全体(忘れてよい)
```ruby
Capybara.default_max_wait_time = 60
```

- マッチしないからといってデフォルト値を増やすべからず
- 逆に失敗の判定をしていた部分で時間がかかるようになってしまう
- デフォルト 2 のままで良い。触ってはいけない
- 重いときはとことん重いので指定のメソッドだけで wait オプションを使う

## 指定の要素が1件になるまで待つ

インクリメンタル検索で結果の数が変動する場合に有用

```ruby
Capybara.assert_selector(".foo", count: 1, wait: 60)
```

## サイトが 200 を返すまで待つ

```ruby
require "faraday"

url = "https://www.google.co.jp/"
loop do
  response = Faraday.get(url)
  p [Time.now.strftime("%F %T"), url, response.reason_phrase]
  if response.success?
    break
  end
  sleep(2)
end
```

Capybara だと戻値がわからないので節操なく faraday を使う

## WEBにアクセスせずにセレクタの練習をする(重要)

```ruby
node = Capybara.string("<a></a>")
node.has_selector?("a") # => true
```

## CSS のセレクタを XPath に変換する(有用)

```ruby
Nokogiri::CSS.xpath_for("*")       # => ["//*"]
Nokogiri::CSS.xpath_for("a")       # => ["//a"]
Nokogiri::CSS.xpath_for("a, b")    # => ["//a", "//b"]
Nokogiri::CSS.xpath_for("a b")     # => ["//a//b"]
Nokogiri::CSS.xpath_for("a > b")   # => ["//a/b"]
Nokogiri::CSS.xpath_for("a[x=y]")  # => ["//a[@x='y']"]
Nokogiri::CSS.xpath_for("a[x*=y]") # => ["//a[contains(@x,'y')]"]
Nokogiri::CSS.xpath_for(".foo")    # => ["//*[contains(concat(' ',normalize-space(@class),' '),' foo ')]"]
Nokogiri::CSS.xpath_for("#foo")    # => ["//*[@id='foo']"]
Nokogiri::CSS.xpath_for("*[foo]")  # => ["//*[@foo]"]
Nokogiri::CSS.xpath_for("p:first") # => ["//p[position()=1]"]
```

## CSS のセレクタは内部で XPath に変換される (重要)

```ruby
Capybara.default_selector # => :css
node = Capybara.string("<a></a>")
node.find("a") # => #<Capybara::Node::Simple tag="a" path="/html/body/a">
```

上だけ見てもわからないが、内部では `a` を `//a` に変換してから探している。

```ruby
xpath = Nokogiri::CSS.xpath_for("a") # => ["//a"]

node = Nokogiri.XML("<a></a>")
node.at(xpath.first) # => #<Nokogiri::XML::Element:0xa8c name="a">
```

## default_selector が :css なのにそのまま XPath も書けるのはなぜか？ (超重要)

`a` でなく `//a` でマッチしている。なぜか？

```ruby
Capybara.default_selector # => :css
node = Capybara.string("<a>xxx</a>")
node.has_selector?("//a") # => true
```

当初、融通を効かせてくれているのだと思っていた。
Nokogiri には `LOOKS_LIKE_XPATH` という定数があり、これにマッチすると XPath と見なしているのかと。

```ruby
Nokogiri::XML::Searchable::LOOKS_LIKE_XPATH # => /^(\.\/|\/|\.\.|\.$)/
node = Nokogiri.XML("<a></a>")
node.at("a")              # => #<Nokogiri::XML::Element:0x9ec name="a">
node.at("//a")            # => #<Nokogiri::XML::Element:0x9ec name="a">
```

だが、それに惑わされてはいけない。
ここで最初の仕組みを思い出す。

**CSS のセレクタは内部で XPath に変換される**

だからこうなる。

```ruby
xpath = Nokogiri::CSS.xpath_for("//a") # => ["////a"]

node = Nokogiri.XML("<a></a>")
node.at(xpath.first) # => #<Nokogiri::XML::Element:0xaa0 name="a" children=[#<Nokogiri::XML::Text:0xa8c "xxx">]>
```

見ると、

1. CSS として `//a` が入力された (そんな CSS の表記はない)
1. `////a` に変換された (そんな XPath の表記もない)
1. しかし、引けた (なぜ？)

たまたまでも動くなら CSS に XPath を書けるってことでいいんじゃない？
いや、絶対だめ。なぜなら── (続く)

## default_selector が :css のときに XPath を書いてはいけない理由 (超重要)

- 動かないセレクタもあるから
- 例えば部分一致のセレクタは動かない

```ruby
Capybara.default_selector # => :css
node = Capybara.string("<a>xxx</a>")
node.has_selector?("//a[text()='xxx']")                    # => true
node.has_selector?("//a[contains(text(), 'x')]") rescue $! # => #<Nokogiri::CSS::SyntaxError: unexpected 'text(' after 'contains('>
```

何度も繰り返すが、

**CSS のセレクタは内部で XPath に変換される**

ので試すと今度は失敗する。

```ruby
Nokogiri::CSS.xpath_for("//a[contains(text(), 'x')]") rescue $! # => #<Nokogiri::CSS::SyntaxError: unexpected 'text(' after 'contains('>
```

- この問題がやっかいなのはだいたいの XPath セレクタは通るところ
- 完全一致のセレクタも通る
- だから部分一致のセレクタだけが通らない理由がわからない
- 常識的に考えて、原因は部分一致の書き方にあると考えてしまう
- そして、ますます深みにはまっていった
  - 実際4年ぐらい混乱していた
  - XPath 恐怖症になっていた
- 思うに `Nokogiri::CSS.xpath_for` が元凶だった
  - CSS として XPath が入力されたらエラーとすべき
  - `//` や `./` で始まる間違ったセレクタをエラーとすべき

結論
- XPath を書くときは **必ず XPath を明示** する

こんなんは偶然動いているだけ。本来エラーとなるコードが素通りしてしまっているだけ。置き換える。
- `assert_selector?("//...")` → `assert_selector?(:xpath, "//...")`
- `assert_selector?("//...")` → `assert_xpath?("//...")`
- `has_selector?("//...")` → `has_xpath?("//...")`
- `find("//...")` → `find(:xpath, "//...")`

## ラベルに正確にマッチさせる

```ruby
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer name:", with: "foo", exact: true)
```

- exact は **正確** の意味
- 毎回 `exact: true` と書く状況なら `Capybara.exact = true` としておく

## グローバルで `exact = true` にすると assert_text も完全一致モードになる？

- ならない
- assert_text には専用の `Capybara.exact_text` がある
- が、これをグローバルで設定することは普通ない
- メソッドに指定するときは `assert_text "xxx", exact: true` と書く
  - `exact_text: true` ではない点に注意

## 改行やスペースの影響で assert_text の判定が揺らぐ

```ruby
Capybara.assert_text("foo bar", normalize_ws: true)
```

- `normalize_ws: true` すると対象を `gsub(/[[:space:]]+/, ' ').strip` する
- なので `foo \n bar` にも `foo bar` がマッチするようになる

## assert_text でマッチしない

- 想定する画面になっていないのがほとんどの原因
- デバッガで止めて以下を確認
  - `Capybara.title`
  - `Capybara.current_url`
  - `Capybara.page.text`
  - `Capybara.page.text.include?("xxx")`

## 画面を覆う巨大な div が邪魔で押せない

`<div class="SpinnerBackdrop"></div>` が画面を覆って目的の button をクリックできない場合、次のようなエラーになる

```
*** Selenium::WebDriver::Error::ElementClickInterceptedError Exception:
element click intercepted: Element <button>...</button> is not clickable at point (1503, 193).
Other element would receive the click: <div class="spinner"></div>
```

### 対策1. 消えるまで待つ

```ruby
Capybara.assert_no_selector?(".spinner", wait: 10)
```

- 10秒経過してもスピナーがでっぱなしならエラーとする

### 対策2. 要素を抹殺する

サイト側の不具合で永遠に残ってしまう場合は強引に消してしまう

```ruby
Capybara.execute_script("document.querySelector('.spinner').remove()")
```

## 確実に選択できるセレクタを得る

- Developer Tool で該当タグを `Copy Selector` でコピる
- あとのことは知らない、今動けばいい──場合に有用

## `Copy Selector` でコピったのに選択できない

- iframe が使われているのが原因
- within_frame(selector) で iframe 内に入る

```html
<body>
  <iframe>
    <form></form>
  </iframe>
</body>
```

```ruby
Capybara.has_selector?("form")     # => false
Capybara.within_frame("iframe") do
  Capybara.assert_selector("form") # => true
end
```

- selector は "iframe" が初期値なので上の場合は selector を省略してもよい

## マウスを重ねると見えるタグを選択する

- `visible: :all` をつける

```ruby
node = Capybara.string("<a style='display:none'></a>")
node.has_selector?("a")                 # => false
node.has_selector?("a", visible: :all)  # => true
```

### visible オプションは他に何が指定できる？

- `visible: :hidden` にすると見えないタグだけが選択できる
- だから普通に選択できたものは逆に選択できなくなる

```ruby
node = Capybara.string("<a></a>")
node.has_selector?("a", visible: :hidden) # => false
```

- 特殊なケースでのテストに有用かもしれない
- `Capybara.ignore_hidden_elements` に指定すると初期値になる
  - 名前が全然違うのがよくない
  - `default_visible` などにすべき
  - そもそも3択で値に`visible` があるのにキーが `visible` なのがイケてない
- 設定値に真偽値も使えるが、わかりにくいので忘れよう
- hidden も基本忘れていい

| シンボル | 見えるタグ | 見えないタグ |        |          |
|----------|------------|--------------|--------|----------|
| visible  | ○         |              | 初期値 | ← true  |
| all      | ○         | ○           |        | ← false |
| hidden   |            | ○           |        |          |

## セレクタのリファクタリング

```html:対象
<button><span>送信する</span></button>
```

タグの構造を含めて完全一致でマッチする

```ruby
has_xpath?("//button/span[text()='送信する']")
```

テキストは部分一致で良い

```ruby
has_xpath?("//button/span[contains(text(), '送信')]")
```

span が別のタグになるかもしれない

```ruby
has_xpath?("//button/*[contains(text(), '送信')]")
```

span が無くなるかもしれない

```ruby
has_xpath?("//button[contains(., '送信')]")
```

contains と書きたくない

```ruby
has_xpath?("//button", text: "送信")
```

`//` を書きたくない

```ruby
has_css?("button", text: "送信")
```

button タグとは限らない

```ruby
has_selector?(:link_or_button, text: "送信")
```

それをクリックしたい

```ruby
find(:link_or_button, text: "送信").click
```

短かく書きたい

```ruby
click_on("送信")
```

## 文言だけを頼りにそれを直下に持つタグを探す

```ruby
find(:xpath, "//*[contains(text(), '送信')]") # => #<Capybara::Node::Simple tag="span" path="/html/body/button/span">
find(:xpath, "//*[text()='送信する']")        # => #<Capybara::Node::Simple tag="span" path="/html/body/button/span">
```

- `text()` は自分の直下のテキストなのでマッチすれば自分自身のタグが返る
- 昨今のフロントエンドは何が click できるのか想像つかない
- とりあえず、その文言を持ったタグを click すれば伝搬するだろう
- そういうとき用

## セレクタに `*` や `.` を使ったときのはまりどころ

トップレベルの HTML タグにマッチしている

```ruby
find(:xpath, "*", text: "送信") # => #<Capybara::Node::Simple tag="html" path="/html">
```

html, body, button, span のすべてのタグがマッチしている

```ruby
find(:xpath, "//*", text: "送信")        rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*" with text "送信">
find(:element, text: "送信")             rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible element nil with text "送信">
find(:xpath, "//*[.='送信する']")        rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*[.='送信する']">
find(:xpath, "//*[contains(., '送信')]") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 4 elements matching visible xpath "//*[contains(., '送信')]">
```

## 「送信」を選択するつもりが「送信確認」も選択してしまう

```ruby
node = Capybara.string("<button>送信確認</button><button>送信</button>")
node.find("button", text: "送信") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 2 elements matching visible css "button" with text "送信">
```

- `exact_text: true` をつけると完全一致になる
  - `exact` なのか `exact_text` なのかややこしい
- `text` オプションを正規表現にする方法もある

```ruby
node.find("button", text: "送信", exact_text: true).path # => "/html/body/button[2]"
node.find("button", text: /\A送信\z/).path               # => "/html/body/button[2]"
```

- xpath であれば contains を避ける

```ruby
node.find(:xpath, "//*[contains(text(), '送信')]") rescue $! # => #<Capybara::Ambiguous: Ambiguous match, found 2 elements matching visible xpath "//*[contains(text(), '送信')]">
node.find(:xpath, "//*[text()='送信']").path # => "/html/body/button[2]"
```

## HTMLを用意して検証する

実際のサイトの深部に行くのが難しい場合はローカルに再現したHTMLで検証する。

```ruby
require "tempfile"

SOURCE = <<~EOT
  <a href="https://www.google.co.jp/">検索</a>
EOT

path = Tempfile.open(["", ".html"]) { |e| e.tap { |e| e << SOURCE } }.path
Capybara.visit("file://#{path}")

Capybara.click_on("検索")
gets
```

- 他者のサイトに無駄なアクセスを重ねて迷惑をかけないようにする意味もある
- 探索中の HTML を保存するには `Capybara.save_page("foo.html")` とする
- 単にセレクタの確認であれば `Capybara.string` を使う
- こちらはクリックイベントなど、ブラウザの挙動を含めて確認したいときに用いる

## `target="_blank"` で開いたタブに移動する

```ruby
Capybara.switch_to_window(Capybara.windows.last)
```

## 新しいタブを開いて移動して何かして閉じて戻る

```ruby
Capybara.within_window(Capybara.open_new_window) do
  # Capybara.visit("https://www.youtube.com/")
  # 何かする
  Capybara.current_window.close
end
```

## タブを閉じる

今いるタブを閉じる

```ruby
if Capybara.current_window != Capybara.windows.first
  Capybara.current_window.close
end
```

他のタブをすべて閉じる

```ruby
(Capybara.windows.drop(1) - [Capybara.current_window]).each(&:close)
```

右側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows.drop(windows.find_index(current_window).next).each(&:close)
end
```

左側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows[1...windows.find_index(current_window)].each(&:close)
end
```

すべてのタブを閉じる

```ruby
Capybara.reset!
```

- いちばん左端のタブ `windows.first` は close できない
- close しようとすると `Not allowed to close the primary window`

## JavaScript を実行して結果を取得する

```ruby
p Capybara.evaluate_script("window.navigator.userAgent")
# >> "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
```

## D&Dでファイルアップロードする

dropybara gem を使わせてもらう

```ruby
`convert logo: file.png`
Capybara.visit("https://css-tricks.com/examples/DragAndDropFileUploading/")
Capybara.page.drop_file("form", "file.png")
```

## テキストフィールドに set したつもりが追記されてしまう

```ruby
Capybara.find(".foo").set("xxx", clear: :backspace)
```

## マウスを乗せないとドロップダウンメニューが開かない

```ruby
Capybara.find(".foo").hover
```

## `command + a` で、すべてを選択

```ruby
Capybara.find("html").send_keys([:command, "a"])
```

## ページの最後まで移動する

```ruby
Capybara.find("html").send_keys(:end)
```

## クリップボードにコピーしてくる

```ruby
module Clipboard
  extend self

  def write(text)
    IO.popen("pbcopy", "w") { |io| io.write(text) }
  end

  def read
    IO.popen("pbpaste", &:read)
  end
end

Clipboard.write("")
Capybara.visit("https://www.ruby-lang.org/ja/")
Capybara.find("html").send_keys([:command, "a"])
Capybara.find("html").send_keys([:command, "c"])
puts Clipboard.read.lines.take(2)
# >> Ruby
# >> A PROGRAMMER'S BEST FRIEND
```

## JavaScript を使ってクリップボードに入れる

```ruby
Clipboard.write("")
Capybara.visit("https://www.google.co.jp/")
Capybara.execute_script("await navigator.clipboard.writeText('foo')")
Clipboard.read # => "foo"
Capybara.first("form input").send_keys([:command, "v"])
```

## YouTubeで画面サイズを調整してスクショを取る

```ruby
Capybara.visit("https://www.youtube.com/watch?v=Ftm2uv7-Ybw")
Capybara.current_window.resize_to(640, 480)
sleep(1)
Capybara.save_screenshot("youtube.png")
```

- YouTubeは画面のリサイズに応じてレイアウトが切り替わる
- が、かなりもっさりゆったりと切り替わる
- なので、このあたりは深追いせず見当つけて sleep を入れる (前言撤回)

## RSpec 実行時にスクショを集める

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
  gem "rspec", require: "rspec/autorun"
end

Capybara.current_driver = :selenium_chrome_headless

RSpec.configure do |config|
  config.before(:example) do |ex|
    @full_description = ex.full_description
  end

  config.include Module.new {
    def image_save
      name = @full_description.gsub(/\s+/, "_")
      Capybara.save_screenshot("#{name}.png")
    end
  }
end

RSpec.describe "Browsing" do
  it "Google" do
    Capybara.visit("https://www.google.co.jp/")
    image_save
  end

  it "YouTube" do
    Capybara.visit("https://www.youtube.com/")
    image_save
  end
end
# >> ..
# >>
# >> Finished in 7.38 seconds (files took 0.11407 seconds to load)
# >> 2 examples, 0 failures
# >>
```

```shell
$ exa -al --no-user Browsing*.png
.rw-r--r-- 130k 18 5 12:24 Browsing_Google.png
.rw-r--r-- 621k 18 5 12:24 Browsing_YouTube.png
```

- 単に保存したファイルの名前からはどこのスクショだったか判断できない
- かといって、いちいちファイル名を指定したくない
- ので full_description を元にファイル名を決める
- スクショが欲しいところに image_save を置く

## 自動化処理中に状況を知らせる

これを定義し、

```ruby
def say(message)
  system "say '#{message}'"
end
```

知らせたいところに置く

```ruby
say "ログイン完了"
```

### say を定義したはずがしゃべらない原因

Thor の say メソッドと干渉し、負けている

## 自動化の敵 reCAPTCHA は人間に頼む

これを定義し、

```ruby
def pause(message = "一時停止")
  say message
  puts message
  s = $stdin.gets.strip
  if s == "d"
    Capybara.using_wait_time(0) { debugger }
  end
end
```

人間の助けが必要なところに挟む

- `$stdin.gets` しているのは Thor から使う場合を考慮している
- `gets` だとファイルと見なした引数を読み込もうとしてしまう
- ついでに `d ENTER` でデバッガーを起動させる

```ruby
pause "reCAPTCHA を倒せ"
```

## visit メソッドを使いやすくする

GET パラメータとしてハッシュを渡せるようにする

```ruby
require "active_support/core_ext/object/to_query"
require "active_support/core_ext/object/blank"

Capybara::Session.prepend Module.new {
  def visit(uri, params = {})
    super [uri, params.to_query.presence].compact.join("?")
  end
}

Capybara.visit("https://www.google.co.jp/search", q: "foo")
```

## 使い捨てサンプル

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
end

Capybara.current_driver = :selenium_chrome

Capybara.visit "https://www.google.co.jp/"
Capybara.first("form input").set("foo")
Capybara.first("form input[type=submit]").click

gets
```

## 画面を50%まで縮小する方法

`command + -` を5回押して50%にしたときと同じ見た目になる

```ruby
Capybara.execute_script("document.body.style.zoom = 0.5")
```

次の方法では動かない

```ruby
Capybara.find("html").send_keys([:command, "-"])
```

また次の方法でもフォントだけは縮小されるが期待した動作とは異なる

```ruby
Capybara.execute_script("document.body.style.fontSize = '50%'")
```

## form の onSubmit フックが邪魔して submit できない

- onSubmit フックを無効化する

```ruby
Capybara.execute_script("document.querySelector('form').onsubmit = undefined")
Capybara.click_on("送信")
```

## 送信ボタンが謎の要素に邪魔されて submit できない

- form を直接 submit する
- 邪魔な要素を `remove()` する手もある

```ruby
Capybara.execute_script("document.querySelector('form').submit()")
```

## 縦に長いフォームでいちばん下までスクロールしたら画面外に出た一番上のテキストフィールドが選択できなくなった

- まさか画面外に出ると選択できない？ と、勘違いしてしまうような何かが邪魔しているはず
- 普通は画面外でも選択できる
- で、`Unable to find visible css "#xxx` が出たらとりあえず `visible: :all` をつけると選択できるようになる

```ruby
Capybara.find("#xxx", visible: :all)
```

## assert を仕掛けまくる

HTML以外のロジックで、こうなっているべきなところにはどんどん assert を仕掛けておく

```ruby
def assert(value)
  if !value
    say "予期せぬ事態です"
    raise "must not happen"
  end
end

assert windows.count == 5
```

## confirm ダイアログの OK を押す方法

```ruby
Capybara.accept_confirm
```

- 正攻法だがいまいち
- 原因がわからないがこの方法は不安定、というかほとんどエラーになる
- `accept_confirm` の直前でデバッガで止め、手動で `accept_confirm` を実行すると確実に `Unable to find modal dialog (Capybara::ModalNotFound)` のエラーになる
- シンプルなHTMLで confirm が出る処理と accept_confirm を連続で実行したときだけ一応動いた

## accept_confirm でエラーになるときの対処法

- `Unable to find modal dialog` が出るので accept_confirm は諦める
- 代わりに confirm 自体が true を返すように変更する

```ruby
Capybara.execute_script("window.confirm = () => true")
```

## 頻繁に出る alert を無視したい

accept_alert で OK を押したことにできるらしいが、こちらも confirm と同様の現象が起きるので処理を無効化するのがてっとり早い

```ruby
Capybara.execute_script("window.alert = () => true")
```

## 閉じたウィンドウにいる状態で open_new_window すると例外がでる

```ruby
Capybara.switch_to_window(Capybara.open_new_window)
Capybara.current_window.close
Capybara.open_new_window rescue $! # => #<Selenium::WebDriver::Error::NoSuchWindowError: no such window: target window already closed
```

生きているウィンドウにいったん戻れば問題ない

```ruby
Capybara.switch_to_window(Capybara.open_new_window)
Capybara.current_window.close
Capybara.switch_to_window(Capybara.windows.first) # ←
Capybara.open_new_window # => #<Window @handle="CDwindow-EA4763FC0D41D15C065A53F092C21BFA">
```

すぐ戻るなら `within_window + open_new_window` を使う

```ruby
Capybara.within_window(Capybara.open_new_window) do
  ...
  Capybara.current_window.close
end
```

## いまアクティブになっている要素を取得する

```ruby
Capybara.current_session.active_element # => #<Capybara::Node::Element tag="body" path="/HTML/BODY[1]">
```

- `Capybara.active_element` では呼べないので注意

## どこかを選択するのではなく今いる場所で入力

```ruby
Capybara.current_session.active_element.send_keys("foo")
```

## インクリメンタル検索の定番コード

- 1件になるまで待つ
- 見つかるまで5秒間は待つ
- 連続で検索するときなどはとくに検索文字列自体を has_selector? で探すの重要

```ruby
Capybara.find("input[type=search").set("alice", clear: :backspace)
if Capybara.has_selector?(".row", text: "alice", count: 1, wait: 5)
  Capybara.find(".row").text
else
  # 見つからなかった
end
```

## Capybara をサポートする便利メソッドは Capybara モジュールではなく DSL モジュールに追加する

Capybara は DSL を extend しているので DSL に定義すれば Capybara.xxx として実行できる

複数の URL を一気に開いて最初のタブにフォーカスするメソッドを追加する例

```ruby
module Capybara::DSL
  def visit_all(urls)
    windows = urls.collect do |e|
      switch_to_window(open_new_window)
      visit(e)
      current_window
    end
    if window = windows.first
      switch_to_window(window)
    end
    windows
  end
end
```

## リファレンス

https://github.com/teamcapybara/capybara
https://gist.github.com/palkan/9a9ba6fd0b54f41428eb62b32f988bfc
