---
title: "Capybara の知見まとめ"
emoji: "🦫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Capybara", "Ruby", "自動化"]
published: false
---

Capybara でブラウザ操作を半自動化する際に得た知見をまとめています。

## グローバルに chromedriver がある

```shell
$ which chromedriver
/usr/local/var/rbenv/shims/chromedriver
```

- それは chromedriver-helper gem の残骸
- 他にも chromedriver で始まる外部コマンドがあるはず
- 全部抹殺する

```shell
$ rm /usr/local/var/rbenv/shims/chromedriver*
```

- gem も消しとけ

```shell
$ gem uni -ax chromedriver-helper
```

## また chromedriver が出てきた

```shell
$ which chromedriver
/usr/local/bin/chromedriver
```

- それは `brew install chromedriver` で入れたやつ
- 抹殺する

```shell
$ brew uninstall chromedriver
```

## chromedriver がないと言われる

```
Failure/Error: raise Error::WebDriverError, self.class.missing_text unless path

Selenium::WebDriver::Error::WebDriverError:
  Unable to find chromedriver. Please download the server from
  https://chromedriver.storage.googleapis.com/index.html and place it somewhere on your PATH.
  More info at https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver.
```

- エラーメッセージ通りに「指定の URL から chromedriver を落として PATH を設定する」などしてはいけない
- webdrivers gem を入れる

## chromedriver はローカルのどこにある？

```shell
$ exa -al --no-user ~/.webdrivers
.rwxr-xr-x 17M 10 7  2021 chromedriver
.rw-r--r--  13 16 5 06:23 chromedriver.version
```

## chromedriver があるのに動作しない

- Google Chrome と chromedriver のバージョンが一致していないのが原因
- バージョン確認手順

```shell
"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --version
~/.webdrivers/chromedriver --version
```

- Google Chrome のバージョンが70以上であれば Google Chrome と chromedriver のバージョンは一致する、と webdrivers の README に書いてある
- しかし Google Chrome が自動アップデートされた直後に同じバージョンの chromedriver が用意されてないことがあった
- それで一回事故って大変な目にあったので、バージョン一致説には時差があるのではないかと疑っている

## バージョンが一致しない事故を防ぐ確実な方法

Google Chrome の自動更新を止める。
これなら絶対にずれることはない。

まず更新チェック頻度を 0 にする。

```shell
defaults write com.google.Keystone.Agent checkInterval 0
```

そしてアップデート関連のプログラムを抹殺＆ダミーに置き換える。
~/Library 側

```shell
sudo rm -R ~/Library/Google/GoogleSoftwareUpdate/
sudo touch ~/Library/Google/GoogleSoftwareUpdate
sudo chmod 444 ~/Library/Google/GoogleSoftwareUpdate
sudo rm ~/Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R ~/Library/Caches/com.google.Keystone*
sudo rm ~/Library/Preferences/com.google.Keystone.Agent.plist
```

/Library 側

```shell
sudo rm -R /Library/Google/GoogleSoftwareUpdate/
sudo touch /Library/Google/GoogleSoftwareUpdate
sudo chmod 444 /Library/Google/GoogleSoftwareUpdate
sudo rm /Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R /Library/Caches/com.google.Keystone*
sudo rm /Library/Preferences/com.google.Keystone.Agent.plist
```

この内容は2000年ごろの作業メモからひっぱってきたものなので現在その通りにして期待通りになるか保証はない (じゃぁ載せんな。危ないし)

## バージョンが一致しない事故を防ぐ楽観的な方法

いざ事故ったら手動で元に戻す。
そのために日々バックアップを取っておく。

```sh:~/bin/capybara-env-backup.sh
#!/bin/sh
# (cd /Applications && rm -fr .git)
# (cd ~/.webdrivers && rm -fr .git)
# exit

cd /Applications
[ ! -d .git ] && git init -q
git add -A "Google Chrome.app"
"./Google Chrome.app/Contents/MacOS/Google Chrome" --version | git commit -uno -F -

cd ~/.webdrivers
[ ! -d .git ] && git init -q
git add -A
./chromedriver --version | git commit -F -
```

これを cron にセットしておく。

webdrivers は Google Chrome のバージョンに合わせた chromedriver を用意してくれるはずなのでバックアップする必要はないのかもしれないが、信用できないほどに事故を恐れているのでこちらもしっかり管理下に入れてすぐ戻せるようにしておく。

それと、いざというときに `/Applications/Google Chrome.app` だけを過去に戻して起動するのか不安ではあるが、とりあえず常時アップデートしていきたい場合はこっちの方がよい。

## Selenium で警告が出る

```
WARN Selenium [DEPRECATION] [:browser_options] :options as a parameter for driver initialization is deprecated. Use :capabilities with an Array of value capabilities/options if necessary instead.
```

- capybara が古いのが原因
- どこで直ったのかはわからないが 3.37.1 以上だと警告は出なくなっていた

## rack application が必要だと言われる

```shell
rack-test requires a rack application, but none was given (ArgumentError)
```

見なかったことにして current_driver に :selenium_chrome を指定する。

```ruby
Capybara.current_driver = :selenium_chrome
```

## `require "capybara/dsl"` するとどうなる？

- 一つのブラウザしか使わないとした上でいろいろ短かく書ける
- Capybara.page で Capybara.current_session を呼べる
- Capybara.page に対するメソッドが Capybara モジュール自体に生える
- つまり Capybara.xxx は Capybara.current_session.xxx を呼ぶ

## 途中で止めてDOMの構造を調べる

- byebug gem を入れる
- 本当は debug gem の方がいいのかもしれない
  - が、 eshell からなぜか (debug gem 使っている irb が) 動かないので byebug にしている
- さくさく調べたいので default_max_wait_time を 0 にしてから debugger を起動する

```ruby
Capybara.using_wait_time(0) { debugger }
```

- snippet 的なやつですぐに入力できるようにしておく
- ブラウザの動作を見える化しておく
  - `Capybara.current_driver = :selenium_chrome`

## 待つ

- assert_xxx 系のメソッドはその状態になるまで待つのに使える
- sleep を使ったら負けだと思え

## 待ち秒数を変更する

指定したメソッドだけ
```ruby
Capybara.assert_title("Google", wait: 1)
```

局所的
```ruby
Capybara.using_wait_time(1) do
  Capybara.default_max_wait_time # => 1
end
```

全体
```ruby
Capybara.default_max_wait_time = 2
```

- マッチしないときにとりあえず値を大きくすればいいんじゃね？ としてしまいがちだけど、これで解決することはほぼない
- 逆にスムーズに失敗の判定をしていた部分で時間がかかって効率が悪くなるので増やすな
- なのでデフォルト 2 のままで良い。触んな
- 指定するとしたら wait オプションだけに留める

## 指定の要素が1件になるまで待つ

- インクリメンタル検索などで結果の数が変動する場合に有用

```ruby
Capybara.assert_selector(".row", count: 1)
```

## 指定のURLになるまで待つ

```ruby
Capybara.visit("https://www.youtube.com/results?search_query=capybara")
Capybara.assert_current_path("/results?search_query=capybara")
```

`Capybara.current_path` でパスがわかるからといって次のように書いてはいけない。

```ruby:間違った例
assert Capybara.current_path == "/results"
```

上のように書いていると、動いたり動かなかったり不安定な動作になる。
その場合は次のように置き換える。

```ruby:正しい例 (クエリ部分は比較しない)
Capybara.assert_current_path("/results", ignore_query: true)
```

## 正確にマッチさせる

ラベル名を指定して値を入力する場合、デフォルトでは次のように書く

```ruby
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer", with: "alice")
```

- 本当のラベルは `Customer name:` だけど部分一致で良いので `Customer` でマッチする
- しかし、あとから Customer の名前が増えると面倒なのでメンテし続けるコードであれば完全一致にしておきたい
- その場合は、グローバルで `Capybara.exact = true` としておく
- exact は **正確** を意味する

```ruby
Capybara.exact = true
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer name:", with: "alice")
```

またグローバルな値よりもオプションを優先するので個別に指定もできる

```ruby
Capybara.fill_in("Customer", with: "alice", exact: false)
Capybara.fill_in("Customer name:", with: "alice", exact: true)
```

## グローバルで `exact = true` にしてしまうと assert_text まで完全一致モードになってしまう？

なってしまわない

- あえて完全一致モードにするには `assert_text "xxx", exact: true` と書く
- `Capybara.exact_text = true` とする手もある
- が、これが必要になることはほぼない

## 改行やスペースの影響で assert_text の判定が揺らぐ

```ruby
Capybara.assert_text("foo bar", normalize_ws: true)
```

- `normalize_ws: true` すると対象を `gsub(/[[:space:]]+/, ' ').strip` する
- なので ` foo \n bar ` にも `foo bar` がマッチするようになる

## assert_text でマッチしない

- 想定している画面になっていないのがほとんどの原因
- デバッガで止めて以下を確認
  - `Capybara.title`
  - `Capybara.current_url`
  - `Capybara.page.text`
  - `Capybara.page.text.include?("xxx")`

## マウス操作では押せるのにプログラムから押せない

1. サイト側の仕組みで処理中の操作を禁止するため画面を div で覆っている
1. 処理が終わって画面を覆うエフェクトは消えた
1. だが、画面を覆う div が完全には取り除かれていない

そんなときに不整合が起きるようだ。
マウスではクリックできるが、Capybara からはクリックできないという。

```
*** Selenium::WebDriver::Error::ElementClickInterceptedError Exception:
element click intercepted: Element <button>...</button> is not clickable at point (1503, 193).
Other element would receive the click: <div class="foo"></div>
```

これは `<div class="foo"></div>` が邪魔して `(1503, 193)` の地点にある目的の button が押せなかったという意味。

この場合は、邪魔している要素を抹殺する。

```ruby
Capybara.execute_script("document.querySelector('.foo').remove()")
```

## 確実に選択できるセレクターを得る

Developer Tool で該当タグの位置を示す情報を `Copy Selector` でコピる

## `Copy Selector` でコピったのに選択できない

- iframe が使われているのが原因
- within_frame(selector) で iframe にスコープする

```html:対象のHTML
<html>
  <body>
    <iframe>
      <form></form>
    </iframe>
  </body>
</html>
```

```ruby
Capybara.has_selector?("form")     # => false
Capybara.within_frame("iframe") do
  Capybara.assert_selector("form") # => true
end
```

## `target="_blank"` で開いたタブに移動する

```ruby
Capybara.switch_to_window(Capybara.windows.last)
```

## 新しいタブを開いて移動して何かして閉じて戻る

```ruby
Capybara.within_window(Capybara.open_new_window) do
  # Capybara.visit("https://www.youtube.com/")
  # 何かする
  Capybara.current_window.close
end
```

## タブを閉じる

今いるタブを閉じる

```ruby
if Capybara.current_window != Capybara.windows.first
  Capybara.current_window.close
end
```

他のタブをすべて閉じる

```ruby
(Capybara.windows.drop(1) - [Capybara.current_window]).each(&:close)
```

右側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows.drop(windows.find_index(current_window).next).each(&:close)
end
```

左側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows[1...windows.find_index(current_window)].each(&:close)
end
```

- いちばん左端のタブ `windows.first` は close できない
- close しようとすると `Not allowed to close the primary window` のエラーになる

## JavaScript を実行して結果を取得する

```ruby
p Capybara.evaluate_script("window.navigator.userAgent")
# >> "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
```

## D&Dでファイルアップロードする

dropybara gem を追加する

```ruby
`convert logo: file.png`
Capybara.visit("https://css-tricks.com/examples/DragAndDropFileUploading/")
Capybara.page.drop_file("form", "file.png")
```

## フィールドに入力しようとしたら追記されてしまう

```ruby
Capybara.find(".foo").set("xxx", clear: :backspace)
```

## マウスを乗せないとドロップダウンメニューが開かない

```ruby
Capybara.find(".foo").hover
```

## `command + a` で、すべてを選択

```ruby
Capybara.find("html").send_keys [:command, "a"]
```

## 画面の一番下まで移動する

```ruby
Capybara.find("html").send_keys(:end)
```

## YouTubeで画面サイズを調整してスクショを取る

```ruby
Capybara.visit("https://www.youtube.com/watch?v=Ftm2uv7-Ybw")
Capybara.current_window.resize_to(640, 480)
sleep(1)
Capybara.save_screenshot("youtube.png")
```

- YouTubeは画面のリサイズに応じてレイアウトが切り替わる
- が、かなりもっさりゆったりと切り替わる
- なので、このあたりは深追いせず見当つけて sleep を入れる (前言撤回)

## RSpec 実行時にスクショを集める

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
  gem "rspec", require: "rspec/autorun"
end

Capybara.current_driver = :selenium_chrome_headless

RSpec.configure do |config|
  config.before(:example) do |ex|
    @full_description = ex.full_description
  end

  config.include Module.new {
    def image_save
      name = @full_description.gsub(/\s+/, "_")
      Capybara.save_screenshot("#{name}.png")
    end
  }
end

RSpec.describe "Browsing" do
  it "Google" do
    Capybara.visit("https://www.google.co.jp/")
    image_save
  end

  it "YouTube" do
    Capybara.visit("https://www.youtube.com/")
    image_save
  end
end
# >> ..
# >>
# >> Finished in 7.38 seconds (files took 0.11407 seconds to load)
# >> 2 examples, 0 failures
# >>
```

```shell
$ exa -al --no-user Browsing*.png
.rw-r--r-- 130k 18 5 12:24 Browsing_Google.png
.rw-r--r-- 621k 18 5 12:24 Browsing_YouTube.png
```

- 引数なしでも `save_screenshot` を呼べるが、保存したファイル名からは、どこのスクショだったか判断できない
- そのため full_description を元にファイル名を決める
- スクショが欲しいところに image_save を書いておく
- もっと便利するなら image_save に引数をつけてファイル名に追加する

## 自動化処理中に状況を知らせる

自動化処理中は画面をずっと見ているわけではないので次のようなメソッドを定義しておき、

```ruby
def say(message)
  system "say '#{message}'"
end
```

知らせたいタイミングでしゃべらせる

```ruby
say "ログイン完了"
```

## 自動化の敵 reCAPTCHA が出たら人間に頼む

こんなメソッドを作っておいて、

```ruby
def pause(message = "一時停止")
  say message
  puts message
  gets
end
```

人間の助けが必要なところで挟む

```ruby
pause "reCAPTCHA を倒せ"
```

## 使い捨てサンプルが欲しい

```ruby
require "bundler/inline"

gemfile(true) do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
end

Capybara.current_driver = :selenium_chrome

Capybara.visit "https://www.google.co.jp/"
Capybara.first("form input").set("Hello, world!")
Capybara.first("form input[type=submit]").click

gets
```
