---
title: "Capybara の知見まとめ"
emoji: "🦫"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Capybara", "Ruby", "自動化"]
published: false
---

Capybara でブラウザ操作を半自動化する際に得た知見をまとめています。

## グローバルに chromedriver がある

```shell
$ which chromedriver
/usr/local/var/rbenv/shims/chromedriver
```

- それは chromedriver-helper gem の残骸
- 他にも chromedriver で始まる外部コマンドがあるはず
- 全部抹殺する

```shell
$ rm /usr/local/var/rbenv/shims/chromedriver*
```

- gem も消す

```shell
$ gem uni -ax chromedriver-helper
```

## また chromedriver が出てきた

```shell
$ which chromedriver
/usr/local/bin/chromedriver
```

- それは `brew install chromedriver` で入れたやつ
- 抹殺する

```shell
$ brew uninstall chromedriver
```

## chromedriver がないと言われる

```
Failure/Error: raise Error::WebDriverError, self.class.missing_text unless path

Selenium::WebDriver::Error::WebDriverError:
  Unable to find chromedriver. Please download the server from
  https://chromedriver.storage.googleapis.com/index.html and place it somewhere on your PATH.
  More info at https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver.
```

- エラーメッセージ通りに「指定の URL から chromedriver を落として PATH を設定」してはいけない
- webdrivers gem を使う

## chromedriver はローカルのどこにある？

```shell
$ exa -al --no-user ~/.webdrivers
.rwxr-xr-x 17M 10 7  2021 chromedriver
.rw-r--r--  13 16 5 06:23 chromedriver.version
```

## chromedriver があるのに動作しない

- Google Chrome と chromedriver のバージョンが一致してない
- バージョンを確認する

```shell
"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --version
~/.webdrivers/chromedriver --version
```

- Google Chrome が 70 以上であれば chromedriver とのバージョンは一致する、と webdrivers の README に書いてある
- しかし Google Chrome が自動アップデートされた直後に同じバージョンの chromedriver が用意されてないことがあった
- それで一回事故って大変な目にあったので、時差があるのではないかと疑っている
- ただ昔のことで記憶が怪しいけどもしかしたら brew の chromedriver と chromedriver-helper gem と webdrivers gem が何をするものか正確に把握できておらず webdrivers gem を正しく使えてなかったのかもしれない。もしそうなら webdrivers にはスマン

## バージョンが一致しない事故を防ぐ確実な方法

Google Chrome の自動更新を止める。
これなら絶対にずれない。

まず更新チェック頻度を 0 にする。

```shell
defaults write com.google.Keystone.Agent checkInterval 0
```

そしてアップデート関連のプログラムを抹殺＆ダミーに置き換える。
~/Library 側

```shell
sudo rm -R ~/Library/Google/GoogleSoftwareUpdate/
sudo touch ~/Library/Google/GoogleSoftwareUpdate
sudo chmod 444 ~/Library/Google/GoogleSoftwareUpdate
sudo rm ~/Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R ~/Library/Caches/com.google.Keystone*
sudo rm ~/Library/Preferences/com.google.Keystone.Agent.plist
```

/Library 側

```shell
sudo rm -R /Library/Google/GoogleSoftwareUpdate/
sudo touch /Library/Google/GoogleSoftwareUpdate
sudo chmod 444 /Library/Google/GoogleSoftwareUpdate
sudo rm /Library/LaunchAgents/com.google.keystone.agent.plist
sudo rm -R /Library/Caches/com.google.Keystone*
sudo rm /Library/Preferences/com.google.Keystone.Agent.plist
```

上の手順はかなり昔の作業メモからひっぱってきたものなので現在その通りにして期待通りになるか保証はない (じゃぁ載せんな。危ないし)

## バージョンが一致しない事故を防ぐ楽観的な方法

いざ事故ったら手動で元に戻す。
そのために日々バックアップを取っておく。

```sh:~/bin/capybara-env-backup.sh
#!/bin/sh
# (cd /Applications && rm -fr .git)
# (cd ~/.webdrivers && rm -fr .git)
# exit

cd /Applications
[ ! -d .git ] && git init -q
git add -A "Google Chrome.app"
"./Google Chrome.app/Contents/MacOS/Google Chrome" --version | git commit -uno -F -

cd ~/.webdrivers
[ ! -d .git ] && git init -q
git add -A
./chromedriver --version | git commit -F -
```

これを cron にセットしておく。

webdrivers は Google Chrome のバージョンに合わせた chromedriver を用意してくれるはずなのでバックアップする必要はないのかもしれないが、信用できないほどに事故を恐れているのでこちらもしっかり管理下に入れてすぐ戻せるようにしておく。

それと、いざというときに `/Applications/Google Chrome.app` だけを過去に戻して起動するのか不安ではあるが、それは運を天に任せる。とりあえず常時アップデートしていきたい場合はこっちの方がよい。

## Selenium で警告が出る

```
WARN Selenium [DEPRECATION] [:browser_options] :options as a parameter for driver initialization is deprecated. Use :capabilities with an Array of value capabilities/options if necessary instead.
```

- capybara が古いのが原因
- どこで直ったのかはわからないが 3.37.1 以上だと警告は出なくなっていた
  - ただ 3.37.1 にするには Ruby 2.7.0 以上を求められる

## rack application が必要だと言われる

```shell
rack-test requires a rack application, but none was given (ArgumentError)
```

見なかったことにして current_driver に :selenium_chrome を指定する。

```ruby
Capybara.current_driver = :selenium_chrome
```

## `require "capybara/dsl"` するとどうなる？

- 一つのブラウザしか使わないとした上でいろいろ短かく書ける
- Capybara.page で Capybara.current_session を呼べる
- Capybara.page に対するメソッドが Capybara モジュール自体に生える
- つまり Capybara.xxx は Capybara.current_session.xxx を呼ぶ

## Capybara.xxx と書くのが面倒

これで `Capybara.` は不要になる

```ruby
class App
  include Capybara::DSL

  def run
    visit "https://www.google.co.jp/"
  end
end

App.new.run
```

が、スコープが曖昧になるので次のようにする。

```ruby
module C
  extend Capybara::DSL
end

C.visit "https://www.google.co.jp/"
```

いや、これなら `C = Capybara` でいいんじゃない？

## 途中で止めてDOMの構造を調べる

- byebug gem を入れる
- 本当は debug gem の方がいいのかもしれない
  - が、 eshell からなぜか (debug gem 使っている irb が) 動かないので byebug にしている
- さくさく調べたいので default_max_wait_time を 0 にしてから debugger を起動する

```ruby
Capybara.using_wait_time(0) { debugger }
```

- snippet 的なやつですぐに入力できるようにしておく

## ローカルの HTML ファイルが読めない

- コマンドラインから `open foo.html` で開けるので `Capybara.visit("foo.html")` で開いてくれても良さそうだけど開けない
  - 親切なエラーメッセージはでない
- `file://` からのフルパスにする

```ruby
file = Pathname("foo.html").expand_path
Capybara.visit("file://#{file}")
```

## 待つ

- assert_xxx 系のメソッドはその状態になるまで待つのに使える
- sleep を使ったら負けだと思え

## 待ち秒数を変更する

指定したメソッドだけ
```ruby
Capybara.assert_title("Google", wait: 1)
```

局所的
```ruby
Capybara.using_wait_time(1) do
  Capybara.default_max_wait_time # => 1
end
```

全体
```ruby
Capybara.default_max_wait_time = 2
```

- マッチしないときにとりあえず値を大きくすればいいんじゃね？ としてしまいがちだけど、これで解決することはほぼない
- 逆に速やかに失敗の判定をしていた部分で時間がかかって効率が悪くなるので増やすな
- なのでデフォルト 2 のままで良い。触んな
- 指定するとしたら wait オプションだけに留める

## 指定の要素が1件になるまで待つ

- インクリメンタル検索などで結果の数が変動する場合に有用

```ruby
Capybara.assert_selector(".row", count: 1)
```

## 指定のURLになるまで待つ

```ruby
Capybara.visit("https://www.youtube.com/results?search_query=capybara")
Capybara.assert_current_path("/results?search_query=capybara")
```

`Capybara.current_path` でパスがわかるからといって次のように書いてはいけない。

```ruby:間違った例
assert Capybara.current_path == "/results"
```

上のように書いていると、動いたり動かなかったり不安定な動作になる。
その場合は次のように置き換える。

```ruby:正しい例 (クエリ部分は比較しない)
Capybara.assert_current_path("/results", ignore_query: true)
```

## 正確にマッチさせる

ラベル名を指定して値を入力する場合、デフォルトでは次のように書く

```ruby
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer", with: "alice")
```

- 本当のラベルは `Customer name:` だけど部分一致で良いので `Customer` でマッチする
- しかし、あとから Customer の名前が増えると面倒なのでメンテし続けるコードであれば完全一致にしておきたい
- その場合は、グローバルで `Capybara.exact = true` としておく
- exact は **正確** を意味する

```ruby
Capybara.exact = true
Capybara.visit("https://httpbin.org/forms/post")
Capybara.fill_in("Customer name:", with: "alice")
```

またグローバルな値よりもオプションを優先するので個別に指定もできる

```ruby
Capybara.fill_in("Customer", with: "alice", exact: false)
Capybara.fill_in("Customer name:", with: "alice", exact: true)
```

## グローバルで `exact = true` にしてしまうと assert_text まで完全一致モードになってしまう？

なってしまわない

- あえて完全一致モードにするには `assert_text "xxx", exact: true` と書く
- `Capybara.exact_text = true` とする手もある
  - が、これが必要になることはない

## 改行やスペースの影響で assert_text の判定が揺らぐ
   
```ruby
Capybara.assert_text("foo bar", normalize_ws: true)
```

- `normalize_ws: true` すると対象を `gsub(/[[:space:]]+/, ' ').strip` する
- なので ` foo \n bar ` にも `foo bar` がマッチするようになる

## assert_text でマッチしない

- 想定している画面になっていないのがほとんどの原因
- デバッガで止めて以下を確認
  - `Capybara.title`
  - `Capybara.current_url`
  - `Capybara.page.text`
  - `Capybara.page.text.include?("xxx")`

## マウス操作では押せるのにプログラムから押せない

1. サイト側の仕組みで処理中の操作を禁止するため画面を div で覆っている
1. 処理が終わって画面を覆うエフェクトは消えた
1. だが、画面を覆う div が完全には取り除かれていない

そんなときに不整合が起きるようだ。
マウスではクリックできるが、Capybara からはクリックできないという。

```
*** Selenium::WebDriver::Error::ElementClickInterceptedError Exception:
element click intercepted: Element <button>...</button> is not clickable at point (1503, 193).
Other element would receive the click: <div class="foo"></div>
```

これは `<div class="foo"></div>` が邪魔して `(1503, 193)` の地点にある目的の button が押せなかったという意味。

この場合は、邪魔している要素を抹殺する。

```ruby
Capybara.execute_script("document.querySelector('.foo').remove()")
```

## 確実に選択できるセレクターを得る

- Developer Tool で該当タグの位置を示す情報を `Copy Selector` でコピる
- あとのことは知らん、今動けばいい──場合に有用

## `Copy Selector` でコピったのに選択できない

- iframe が使われているのが原因
- within_frame(selector) で iframe にスコープする

```html:対象のHTML
<html>
  <body>
    <iframe>
      <form></form>
    </iframe>
  </body>
</html>
```

```ruby
Capybara.has_selector?("form")     # => false
Capybara.within_frame("iframe") do
  Capybara.assert_selector("form") # => true
end
```

## xpath は使うな

```html
<button>送信する</button>
```

に対しては次のように書けばマッチする

```ruby
Capybara.assert_selector(:xpath, "//button[contains(text(), '送信')]")
```

しかし button のコンポーネントの構造が少し変わって次のようになるともうマッチしなくなる。

```html
<button>
  <span>送信する</span>
</button>
```

この場合は次のように書かないといけない。

```ruby
Capybara.assert_selector(:xpath, "//button/span[contains(text(), '送信')]")
```

もう少し汎用化するとアスタリクスを使って次のように書ける。

```ruby
Capybara.assert_selector(:xpath, "//button/*[contains(text(), '送信')]")
```

じゃぁ最初からそうしとけば良くないかと思うけどこれだと `<button>送信する</button>` にはマッチしない。

そんな感じで xpath は当たりが厳しくメンテもしづらくなるので使うな。

## シンプルに操作する

```html
<button>
  <span>送信する</span>
</button>
```

xpath と違って CSS のセレクタではテキスト要素を指定できなさそうだが text オプションをつければ反応してくれる。

```ruby
Capybara.assert_selector("button", text: "送信")
```

これは `<button>送信する</button>` にもマッチする。
で、assert_selector は find に置き換えれるので click するならこうなる。

```ruby
Capybara.find("button", text: "送信").click
```

もっと簡単に書くならこうなる。

```ruby
Capybara.click_on("送信")
Capybara.click_button("送信")
Capybara.click_link_or_button("送信")
```

## HTMLを自分で用意して検証する

実際のサイトの深部だったりして行くのが難しい場合はローカルに再現したHTMLを読ませる。

```ruby
require "tempfile"

SOURCE = <<~EOT
<div>
  <button>送信</button>
</div>
EOT

path = Tempfile.open(["", ".html"]) { |e| e.tap { |e| e << SOURCE } }.path
Capybara.visit("file://#{path}")

Capybara.assert_selector("button")
```

実際のサイトで不自然な動作検証を重ねていると怪しまれてブロックされる心配もあるのでそのような場合もローカルで検証する。
HTML は `Capybara.save_page("foo.html")` で保存できる。
あと Ruby の Tempfile ライブラリがもうちょっと使いやすくなってくれるとありがたい(小声)

## `target="_blank"` で開いたタブに移動する

```ruby
Capybara.switch_to_window(Capybara.windows.last)
```

## 新しいタブを開いて移動して何かして閉じて戻る

```ruby
Capybara.within_window(Capybara.open_new_window) do
  # Capybara.visit("https://www.youtube.com/")
  # 何かする
  Capybara.current_window.close
end
```

## タブを閉じる

今いるタブを閉じる

```ruby
if Capybara.current_window != Capybara.windows.first
  Capybara.current_window.close
end
```

他のタブをすべて閉じる

```ruby
(Capybara.windows.drop(1) - [Capybara.current_window]).each(&:close)
```

右側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows.drop(windows.find_index(current_window).next).each(&:close)
end
```

左側のタブを閉じる

```ruby
Capybara.instance_eval do
  windows[1...windows.find_index(current_window)].each(&:close)
end
```

- いちばん左端のタブ `windows.first` は close できない
- close しようとすると `Not allowed to close the primary window` のエラーになる

## JavaScript を実行して結果を取得する

```ruby
p Capybara.evaluate_script("window.navigator.userAgent")
# >> "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
```

## D&Dでファイルアップロードする

dropybara gem を追加する

```ruby
`convert logo: file.png`
Capybara.visit("https://css-tricks.com/examples/DragAndDropFileUploading/")
Capybara.page.drop_file("form", "file.png")
```

## フィールドに入力しようとしたら追記されてしまう

```ruby
Capybara.find(".foo").set("xxx", clear: :backspace)
```

## マウスを乗せないとドロップダウンメニューが開かない

```ruby
Capybara.find(".foo").hover
```

## `command + a` で、すべてを選択

```ruby
Capybara.find("html").send_keys [:command, "a"]
```

## 画面の一番下まで移動する

```ruby
Capybara.find("html").send_keys(:end)
```

## YouTubeで画面サイズを調整してスクショを取る

```ruby
Capybara.visit("https://www.youtube.com/watch?v=Ftm2uv7-Ybw")
Capybara.current_window.resize_to(640, 480)
sleep(1)
Capybara.save_screenshot("youtube.png")
```

- YouTubeは画面のリサイズに応じてレイアウトが切り替わる
- が、かなりもっさりゆったりと切り替わる
- なので、このあたりは深追いせず見当つけて sleep を入れる (前言撤回)

## RSpec 実行時にスクショを集める

```ruby
require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
  gem "rspec", require: "rspec/autorun"
end

Capybara.current_driver = :selenium_chrome_headless

RSpec.configure do |config|
  config.before(:example) do |ex|
    @full_description = ex.full_description
  end

  config.include Module.new {
    def image_save
      name = @full_description.gsub(/\s+/, "_")
      Capybara.save_screenshot("#{name}.png")
    end
  }
end

RSpec.describe "Browsing" do
  it "Google" do
    Capybara.visit("https://www.google.co.jp/")
    image_save
  end

  it "YouTube" do
    Capybara.visit("https://www.youtube.com/")
    image_save
  end
end
# >> ..
# >>
# >> Finished in 7.38 seconds (files took 0.11407 seconds to load)
# >> 2 examples, 0 failures
# >>
```

```shell
$ exa -al --no-user Browsing*.png
.rw-r--r-- 130k 18 5 12:24 Browsing_Google.png
.rw-r--r-- 621k 18 5 12:24 Browsing_YouTube.png
```

- 引数なしでも `save_screenshot` を呼べるが、保存したファイル名からは、どこのスクショだったか判断できない
- そのため full_description を元にファイル名を決める
- スクショが欲しいところに image_save を書いておく
- もっと便利するなら image_save に引数をつけてファイル名に追加する

## 自動化処理中に状況を知らせる

自動化処理中は画面をずっと見ているわけではないので次のようなメソッドを定義しておき、

```ruby
def say(message)
  system "say '#{message}'"
end
```

知らせたいタイミングでしゃべらせる

```ruby
say "ログイン完了"
```

## 自動化の敵 reCAPTCHA が出たら人間に頼む

こんなメソッドを作っておいて、

```ruby
def pause(message = "一時停止")
  say message
  puts message
  gets
end
```

人間の助けが必要なところで挟む

```ruby
pause "reCAPTCHA を倒せ"
```

## 使い捨てサンプルが欲しい

```ruby
require "bundler/inline"

gemfile(true) do # false にするとコンソールに表示しない
  source "https://rubygems.org"
  gem "webdrivers"
  gem "capybara", require: "capybara/dsl"
end

Capybara.current_driver = :selenium_chrome

Capybara.visit "https://www.google.co.jp/"
Capybara.first("form input").set("Hello, world!")
Capybara.first("form input[type=submit]").click

gets
```
